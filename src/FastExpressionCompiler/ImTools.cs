// <auto-generated/>
/*
The MIT License (MIT)

Copyright (c) 2016-2025 Maksim Volkau

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

// ReSharper disable once InconsistentNaming
#nullable disable

#if !NETSTANDARD2_0_OR_GREATER && !NET472
#define SUPPORTS_UNSAFE
#define SUPPORTS_CREATE_SPAN
#endif

#if LIGHT_EXPRESSION
namespace FastExpressionCompiler.LightExpression.ImTools;
#else
namespace FastExpressionCompiler.ImTools;
#endif

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Threading;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Diagnostics.CodeAnalysis;

#if NET8_0_OR_GREATER
using System.Runtime.Intrinsics;
#endif

using static SmallMap;

/// <summary>Helpers and polyfills for the missing things in the old .NET versions</summary>
public static class RefTools<T>
{
    /// <summary>Polyfill for the missing returning the `ref` in the failed search scenario.
    /// Note that the result is the `null` even for the struct `T`, so avoid the accessing its members without the check</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref T GetNullRef() =>
#if SUPPORTS_UNSAFE
        ref Unsafe.NullRef<T>();
#else
        ref _missing;
    internal static T _missing = default;
#endif
}

/// <summary>Wrapper for the array of the specific capacity and a separate count less or equal to this capacity </summary>
public struct SmallList<T> : IIndexed<T>
{
    /// <summary>Array of items</summary>
    public T[] Items;

    /// <summary>The count of used items</summary>
    public int Count { get; set; }

    /// <inheritdoc/>
    [MethodImpl((MethodImplOptions)256)]
    public ref T GetSurePresentRef(int index) => ref Items.GetSurePresentRef(index);

    /// <inheritdoc/>
    public ref T this[int index]
    {
        [MethodImpl((MethodImplOptions)256)]
        get
        {
            if (index >= 0 & index < Count)
                return ref Items.GetSurePresentRef(index);
            return ref SmallList.ThrowIndexOutOfBounds<T>(index, Count);
        }
    }

    /// <summary>Creating this stuff</summary>
    public SmallList(T[] items, int count)
    {
        Items = items;
        Count = count;
    }

    /// <summary>Creates the wrapper out of the items</summary>
    public SmallList(T[] items) : this(items, items.Length) { }

    /// <summary>Popping candy</summary>
    public void Pop() => --Count;
}

/// <summary>SmallList module he-he</summary>
public static class SmallList
{
    internal const int ForLoopCopyCount = 4;
    internal const int DefaultInitialCapacity = 4;

    [MethodImpl(MethodImplOptions.NoInlining)]
    internal static ref T ThrowIndexOutOfBounds<T>(int index, int count) =>
        throw new IndexOutOfRangeException($"Index {index} is out of range of count {count} for  {typeof(T)},..>.");

    [MethodImpl((MethodImplOptions)256)]
    internal static void Expand<T>(ref T[] items, T[] newItems)
    {
        Debug.Assert(newItems != null, "New items length should be more than the current items length");
        Debug.Assert(newItems.Length > items.Length, "New items length should be more than the current items length");
        if (items.Length > ForLoopCopyCount)
            Array.Copy(items, newItems, items.Length);
        else
            for (var i = 0; i < items.Length; ++i)
                newItems[i] = items[i];
        items = newItems;
    }

    /// <summary>Appends the new default item at the end of the items. Assumes that `index lte items.Length`! 
    /// `items` should be not null</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref T AddDefaultToNotNullItemsAndGetRef<T>(ref T[] items, int index)
    {
        Debug.Assert(index <= items.Length);
        if (index == items.Length)
        {
            var newCount = (items.Length << 1) | 1; // 1 is to account for the empty array, have fun to guess the new length, ha-ha ;-P
            Expand(ref items, new T[newCount]);
        }
        return ref items.GetSurePresentRef(index);
    }

    /// <summary>Appends the new default item at the end of the items. Assumes that `index lte items.Length`, `items` may be null</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref T AddDefaultAndGetRef<T>(ref T[] items, int index, int initialCapacity = DefaultInitialCapacity)
    {
        if (items == null)
        {
            Debug.Assert(index == 0);
            items = new T[initialCapacity];
            return ref items.GetSurePresentFirstRef();
        }

        Debug.Assert(index <= items.Length);
        if (index == items.Length)
        {
            var newCount = (items.Length << 1) | 1; // 1 is to account for the empty array, have fun to guess the new length, ha-ha ;-P
            Expand(ref items, new T[newCount]);
        }
        return ref items.GetSurePresentRef(index);
    }

    /// <summary>Appends the new default item at the end of the items. Assumes that `index lte items.Length`, `items` may be null</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref T AddDefaultAndGetRef<T, TPool>(ref T[] items, ref TPool pool, int index, int initialCapacity = DefaultInitialCapacity)
        where TPool : struct, ISmallArrayPool<T>
    {
        if (items == null)
        {
            Debug.Assert(index == 0);
            items = pool.RentMinOrNew(initialCapacity);
            return ref items.GetSurePresentFirstRef();
        }

        Debug.Assert(index <= items.Length);
        if (index == items.Length)
        {
            var newCount = (items.Length << 1) | 1; // 1 is to account for the empty array, have fun to guess the new length, ha-ha ;-P
            var newItems = pool.RentMinOrNew(newCount);
            Debug.Assert(newItems != null);
            var oldItems = items;
            Expand(ref items, newItems);
            pool.ReuseIfPossible(oldItems);
        }
        return ref items.GetSurePresentRef(index);
    }

    /// <summary>Returns surely present item ref by its index without boundary checks</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref T GetSurePresentFirstRef<T>(this T[] source) =>
#if SUPPORTS_UNSAFE
        ref MemoryMarshal.GetArrayDataReference(source);
#else
        ref source[0];
#endif

    /// <summary>Returns surely present item ref by its index without boundary checks</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref T GetSurePresentRef<T>(this T[] source, int index) =>
#if SUPPORTS_UNSAFE
        ref Unsafe.Add(ref MemoryMarshal.GetArrayDataReference(source), index);
#else
        ref source[index];
#endif

#if NET7_0_OR_GREATER
    /// <summary>Get the item by-ref without bounds check</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref T GetSurePresentRef<T>(this ref T source, int index) where T : struct =>
        ref Unsafe.Add(ref source, index);
#endif

    /// <summary>Get the item without bounds check</summary>
    [MethodImpl((MethodImplOptions)256)]
#if NET7_0_OR_GREATER
    internal static T GetSurePresent<T>(this ref T source, int index) where T : struct => Unsafe.Add(ref source, index);
#else
    internal static T GetSurePresent<T>(this T[] source, int index) => source[index];
#endif

    // todo: @perf add the not null variant
    /// <summary>Appends the new default item to the list and returns ref to it for write or read</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref T AddDefaultAndGetRef<T>(this ref SmallList<T> source, int initialCapacity = DefaultInitialCapacity) =>
        ref AddDefaultAndGetRef(ref source.Items, source.Count++, initialCapacity);

    /// <summary>Appends the new item to the list</summary>
    // todo: @perf add the not null variant
    [MethodImpl((MethodImplOptions)256)]
    public static void Add<T>(this ref SmallList<T> source, in T item, int initialCapacity = DefaultInitialCapacity) =>
        AddDefaultAndGetRef(ref source.Items, source.Count++, initialCapacity) = item;

    /// <summary>Looks for the item in the list and return its index if found or -1 for the absent item</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static int TryGetIndex<T, TEq>(this T[] items, in T it, int startIndex, int count, TEq eq = default,
        int notFoundResult = -1)
        where TEq : struct, IEq<T>
    {
        Debug.Assert(items != null);
        for (var i = startIndex; i < count; ++i)
        {
            ref var di = ref items[i]; // todo: @perf Marshall?
            if (eq.Equals(it, di))
                return i;
        }
        return notFoundResult;
    }

    /// <summary>Looks for the item in the list and return its index if found or -1 for the absent item</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static int TryGetIndex<T, TEq>(this ref SmallList<T> source, T it, TEq eq = default)
        where TEq : struct, IEq<T>
        => source.Items.TryGetIndex(it, 0, source.Count, eq);

    /// <summary>Returns the index of the found item or appends the item to the end of the list, and returns its index</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static int GetIndexOrAdd<T, TEq>(this ref SmallList<T> source, in T item, TEq eq = default)
        where TEq : struct, IEq<T>
    {
        var count = source.Count;
        if (count != 0)
        {
            var index = TryGetIndex(source.Items, in item, 0, count, eq);
            if (index != -1)
                return index;
        }
        source.AddDefaultAndGetRef() = item;
        return count;
    }
}

#pragma warning disable CS9101 // UnscopedRef goes wrong on Ubuntu

/// <summary>Utilities for Stack4, Stack8, etc.</summary>
public static class Stack
{
    [MethodImpl(MethodImplOptions.NoInlining)]
    internal static ref T ThrowIndexOutOfBounds<T>(int index, int capacity) =>
        throw new IndexOutOfRangeException($"Index {index} is out of range for Stack{capacity}<{typeof(T)},..>.");
}

/// <summary>Abstracts over collection of the items on stack of the fixed Capacity,
/// to be used as a part of the hybrid data structures which grow from stack to heap</summary>
public interface IIndexed<T>
{
    /// <summary>Count of items to be indexed</summary>
    int Count { get; }

    /// <summary>Returns the item by ref to read and write the item value,
    /// but does not check the index bounds comparing to the `this[index]`</summary>
    [UnscopedRef]
    ref T GetSurePresentRef(int index);

    /// <summary>Indexer returning the item by ref to read and write the item value</summary>
    [UnscopedRef]
    ref T this[int index] { get; }
}

/// <summary>Stack with the Size information to check it at compile time</summary>
public interface IStack<T, TStack> : IIndexed<T>
    where TStack : struct, IStack<T, TStack>
{
    /// <summary>Maximum count of items hold in stack</summary>
    int Capacity { get; }

#if SUPPORTS_CREATE_SPAN
    /// <summary>Creates a span over the stack items</summary>
    public Span<T> AsSpan();
#endif
}

/// <summary>Stack with the Size information to check it at compile time</summary>
public interface IStack<T, TSize, TStack> : IStack<T, TStack>
    where TSize : struct, ISize
    where TStack : struct, IStack<T, TSize, TStack>
{
}

/// <summary>Base marker for collection or container holding some number of items</summary>
public interface ISize
{
    /// <summary>Returns the size of the collection or container</summary>
    int Size { get; }
}
/// <summary>Marker for collection or container holding 2 or items</summary>
public interface ISize2Plus : ISize { }
/// <summary>Marker for collection or container holding 4 or more items</summary>
public interface ISize4Plus : ISize2Plus { }
/// <summary>Marker for collection or container holding 8 or more items</summary>
public interface ISize8Plus : ISize4Plus { }
/// <summary>Marker for collection or container holding 16 or more items</summary>
public interface ISize16Plus : ISize8Plus { }

/// <summary>Marker for collection or container holding 0 items</summary>
public struct Size0 : ISize
{
    /// <inheritdoc/>
    public int Size => 0;
}

/// <summary>Marker for collection or container holding 4 items</summary>
public struct Size2 : ISize2Plus
{
    /// <inheritdoc/>
    public int Size => 2;
}
/// <summary>Marker for collection or container holding 4 items</summary>
public struct Size4 : ISize4Plus
{
    /// <inheritdoc/>
    public int Size => 4;
}
/// <summary>Marker for collection or container holding 8 items</summary>
public struct Size8 : ISize8Plus
{
    /// <inheritdoc/>
    public int Size => 8;
}
/// <summary>Marker for collection or container holding 16 items</summary>
public struct Size16 : ISize16Plus
{
    /// <inheritdoc/>
    public int Size => 16;
}

/// <summary>Implementation of `IStack` for 2 items on stack</summary>
[StructLayout(LayoutKind.Sequential, Pack = 1)]
public struct Stack2<T> : IStack<T, Size2, Stack2<T>>
{
    /// <inheritdoc/>
    public int Capacity => 2;
    int IIndexed<T>.Count => Capacity;

    internal T _it0, _it1;

    /// <inheritdoc/>
    [UnscopedRef]
    [MethodImpl((MethodImplOptions)256)]
    public ref T GetSurePresentRef(int index)
    {
#if SUPPORTS_UNSAFE
        return ref Unsafe.Add(ref _it0, index);
#else
        switch (index)
        {
            case 0: return ref _it0;
            default: return ref _it1;
        }
#endif
    }

    /// <inheritdoc/>
    [UnscopedRef]
    public ref T this[int index]
    {
        [MethodImpl((MethodImplOptions)256)]
        get
        {
            if (index >= 0 & index < Capacity)
                return ref GetSurePresentRef(index);
            return ref Stack.ThrowIndexOutOfBounds<T>(index, Capacity);
        }
    }

#if SUPPORTS_CREATE_SPAN
    /// <inheritdoc/>
    [MethodImpl((MethodImplOptions)256)]
    public Span<T> AsSpan() => MemoryMarshal.CreateSpan(ref _it0, Capacity);
#endif
}

/// <summary>Implementation of `IStack` for 4 items on stack</summary>
[StructLayout(LayoutKind.Sequential, Pack = 1)]
public struct Stack4<T> : IStack<T, Size4, Stack4<T>>
{
    /// <inheritdoc/>
    public int Capacity => 4;
    int IIndexed<T>.Count => Capacity;

    internal T _it0, _it1, _it2, _it3;

    /// <inheritdoc/>
    [UnscopedRef]
    [MethodImpl((MethodImplOptions)256)]
    public ref T GetSurePresentRef(int index)
    {
#if SUPPORTS_UNSAFE
        return ref Unsafe.Add(ref _it0, index);
#else
        switch (index)
        {
            case 0: return ref _it0;
            case 1: return ref _it1;
            case 2: return ref _it2;
            default: return ref _it3;
        }
#endif
    }

    /// <inheritdoc/>
    [UnscopedRef]
    public ref T this[int index]
    {
        [MethodImpl((MethodImplOptions)256)]
        get
        {
            if (index >= 0 & index < Capacity)
                return ref GetSurePresentRef(index);
            return ref Stack.ThrowIndexOutOfBounds<T>(index, Capacity);
        }
    }

#if SUPPORTS_CREATE_SPAN
    /// <inheritdoc/>
    [MethodImpl((MethodImplOptions)256)]
    public Span<T> AsSpan() => MemoryMarshal.CreateSpan(ref _it0, Capacity);
#endif
}

/// <summary>Implementation of `IStack` for 8 items on stack</summary>
[StructLayout(LayoutKind.Sequential, Pack = 1)]
public struct Stack8<T> : IStack<T, Size8, Stack8<T>>
{
    /// <inheritdoc/>
    public int Capacity => 8;
    int IIndexed<T>.Count => Capacity;

    internal T _it0, _it1, _it2, _it3, _it4, _it5, _it6, _it7;

    /// <inheritdoc/>
    [UnscopedRef]
    [MethodImpl((MethodImplOptions)256)]
    public ref T GetSurePresentRef(int index)
    {
#if SUPPORTS_UNSAFE
        return ref Unsafe.Add(ref _it0, index);
#else
        switch (index)
        {
            case 0: return ref _it0;
            case 1: return ref _it1;
            case 2: return ref _it2;
            case 3: return ref _it3;
            case 4: return ref _it4;
            case 5: return ref _it5;
            case 6: return ref _it6;
            default: return ref _it7;
        }
#endif
    }

    /// <inheritdoc/>
    [UnscopedRef]
    public ref T this[int index]
    {
        [MethodImpl((MethodImplOptions)256)]
        get
        {
            if (index >= 0 & index < Capacity)
                return ref GetSurePresentRef(index);
            return ref Stack.ThrowIndexOutOfBounds<T>(index, Capacity);
        }
    }

#if SUPPORTS_CREATE_SPAN
    /// <inheritdoc/>
    [MethodImpl((MethodImplOptions)256)]
    public Span<T> AsSpan() => MemoryMarshal.CreateSpan(ref _it0, Capacity);
#endif
}

/// <summary>Implementation of `IStack` for 16 items on stack</summary>
[StructLayout(LayoutKind.Sequential, Pack = 1)]
public struct Stack16<T> : IStack<T, Size16, Stack16<T>>
{
    /// <inheritdoc/>
    public int Capacity => 16;
    int IIndexed<T>.Count => Capacity;

    internal T _it0, _it1, _it2, _it3, _it4, _it5, _it6, _it7;
    internal T _it8, _it9, _it10, _it11, _it12, _it13, _it14, _it15;

    /// <inheritdoc/>
    [UnscopedRef]
    [MethodImpl((MethodImplOptions)256)]
    public ref T GetSurePresentRef(int index)
    {
#if SUPPORTS_UNSAFE
        return ref Unsafe.Add(ref _it0, index);
#else
        switch (index)
        {
            case 0: return ref _it0;
            case 1: return ref _it1;
            case 2: return ref _it2;
            case 3: return ref _it3;
            case 4: return ref _it4;
            case 5: return ref _it5;
            case 6: return ref _it6;
            case 7: return ref _it7;
            case 8: return ref _it8;
            case 9: return ref _it9;
            case 10: return ref _it10;
            case 11: return ref _it11;
            case 12: return ref _it12;
            case 13: return ref _it13;
            case 14: return ref _it14;
            default: return ref _it15;
        }
#endif
    }

    /// <inheritdoc/>
    [UnscopedRef]
    public ref T this[int index]
    {
        [MethodImpl((MethodImplOptions)256)]
        get
        {
            if (index >= 0 & index < Capacity)
                return ref GetSurePresentRef(index);
            return ref Stack.ThrowIndexOutOfBounds<T>(index, Capacity);
        }
    }

#if SUPPORTS_CREATE_SPAN
    /// <inheritdoc/>
    [MethodImpl((MethodImplOptions)256)]
    public Span<T> AsSpan() => MemoryMarshal.CreateSpan(ref _it0, Capacity);
#endif
}

/// <summary>Abstraction over the small array pool to rent and return the arrays of small sizes, from 1 to N</summary>
public interface ISmallArrayPool<T>
{
    /// <summary>Gets the maximum array length that can be rented from the pool.</summary>
    int MaxArrayLength { get; }
    /// <summary>Rents an array from the pool or creates a new one if none is available.</summary>
    T[] RentExactOrNew(int exactLength);
    T[] RentMinOrNew(int minLength);
    /// <summary>Returns an array to the pool if it is fits the `MaxArrayLength`.</summary>
    void ReuseIfPossible(T[] array);
}

/// <summary>Implementation of `ISmallArrayPool` which does not pool anything, just creates new arrays</summary>
public struct NoArrayPool<T> : ISmallArrayPool<T>
{
    /// <inheritdoc/>
    public int MaxArrayLength => 0;

    /// <inheritdoc/>
    [MethodImpl((MethodImplOptions)256)]
    public T[] RentExactOrNew(int exactLength) => new T[exactLength];

    /// <inheritdoc/>
    [MethodImpl((MethodImplOptions)256)]
    public T[] RentMinOrNew(int minLength) => new T[minLength];

    /// <inheritdoc/>
    [MethodImpl((MethodImplOptions)256)]
    public void ReuseIfPossible(T[] array) { }
}

/// <summary>Abstraction over how the array is cleared before putting it back to the pool</summary>
public interface IClearItems<T>
{
    /// <summary>Clears the items in the array from `startIndex` for `length` items</summary>
    void Clear(T[] array, int startIndex, int length);
}

/// <summary>Does not clear anything</summary>
public struct ClearItemsNo<T> : IClearItems<T>
{
    /// <inheritdoc/>
    [MethodImpl((MethodImplOptions)256)]
    public void Clear(T[] array, int startIndex, int length) { }
}

/// <summary>Clears the items using `Array.Clear`</summary>
public struct ClearItemsFast<T> : IClearItems<T>
{
    /// <inheritdoc/>
    [MethodImpl((MethodImplOptions)256)]
    public void Clear(T[] array, int startIndex, int length) => Array.Clear(array, startIndex, length);
}

/// <summary>Implementation of `ISmallArrayPool` which provides a pool of arrays.</summary>
public struct ProvidedArrayPool<T, TClearItems> : ISmallArrayPool<T>
    where TClearItems : struct, IClearItems<T>
{
    private T[][] _arrays;
    private int _maxArrayLength;

    /// <summary>Inits the pool with some shared array pool</summary>
    public ProvidedArrayPool(T[][] pool, int maxArrayLength) : this() => Init(pool, maxArrayLength);

    /// <summary>Inits the pool with some shared array pool</summary>
    [MethodImpl((MethodImplOptions)256)]
    public void Init(T[][] arrays, int maxArrayLength)
    {
        _arrays = arrays;
        _maxArrayLength = maxArrayLength;
    }

    /// <summary>Adds the arrays from the shared pool to the target, making the target at least as large as the shared pool.</summary>
    public void MergeInto(ref T[][] target)
    {
        var source = _arrays;
        if (target == null || target.Length == 0)
            target = source;
        else if (source != null && source.Length != 0)
        {
            if (target.Length < source.Length)
                Array.Resize(ref target, source.Length);
            for (var i = 0; i < target.Length; ++i)
                if (target[i] == null)
                {
                    var sourceArr = source.GetSurePresentRef(i);
                    Debug.Assert(sourceArr == null || sourceArr.Length == i + 1, $"Expecting the source array {sourceArr.Length} to be of the right length");
                    target[i] = sourceArr;
                }
        }
    }

    /// <inheritdoc/>
    public int MaxArrayLength => _maxArrayLength;

    /// <inheritdoc/>
    [MethodImpl((MethodImplOptions)256)]
    public T[] RentExactOrNew(int exactLength)
    {
        Debug.Assert(exactLength != 0);
        if (exactLength > _maxArrayLength)
            return new T[exactLength];

        if (_arrays == null)
            _arrays = new T[_maxArrayLength][];
        else if (_arrays.Length < _maxArrayLength)
            Array.Resize(ref _arrays, _maxArrayLength);

        return Interlocked.Exchange(ref _arrays[exactLength - 1], null) ?? new T[exactLength];
    }

    /// <inheritdoc/>
    [MethodImpl((MethodImplOptions)256)]
    public T[] RentMinOrNew(int minLength)
    {
        Debug.Assert(minLength != 0);
        if (minLength > _maxArrayLength)
            return new T[minLength];

        if (_arrays == null)
            _arrays = new T[_maxArrayLength][];
        else if (_arrays.Length < _maxArrayLength)
            Array.Resize(ref _arrays, _maxArrayLength);

        var len = minLength;
        while (len < _arrays.Length)
        {
            var arr = Interlocked.Exchange(ref _arrays.GetSurePresentRef(len - 1), null);
            if (arr != null)
                return arr;
            ++len;
        }

        return new T[minLength];
    }

    /// <inheritdoc/>
    [MethodImpl((MethodImplOptions)256)]
    public void ReuseIfPossible(T[] array)
    {
        if (array == null | _arrays == null) return;
        var arrayLength = array.Length;
        if (arrayLength != 0 && arrayLength <= _arrays.Length)
        {
            default(TClearItems).Clear(array, 0, arrayLength);
            Interlocked.Exchange(ref _arrays[arrayLength - 1], array);
        }
    }
}

/// <summary>Abstraction over the small list which keeps some items on stack and grows to heap when needed</summary>
public interface ISmallList<T> : IIndexed<T>, IEnumerable<T>
{
    /// <summary>Adds a default item to the list and returns a reference to it. Basically it just ensure that list contains the slot for the new item</summary>
    [UnscopedRef]
    ref T AddDefaultAndGetRef();

    /// <summary>Adds the item to the end of the list aka the Stack.Push. Returns the index of the added item.</summary>
    int Add(in T item);

    /// <summary>Returns the index of the found item or -1 for the absent item</summary>
    int TryGetIndex<TEq>(in T item, TEq eq = default) where TEq : struct, IEq<T>;

    /// <summary>Removes the last item from the list. List should not be empty.</summary>
    void RemoveLastSurePresentItem();

    /// <summary>Clears the list.</summary>
    void Clear();

    /// <summary>Copies the contents of the list to the passed array.</summary>
    void CopyToArray(T[] arr, int copyToIndex = 0);
}

/// <summary>Generic version of SmallList abstracted for how much items are on the stack</summary>
public struct SmallList<T, TStack, TPool> : ISmallList<T>
    where TStack : struct, IStack<T, TStack>
    where TPool : struct, ISmallArrayPool<T>
{
    /// <summary>Let's enable access to the Count, so you can Pop the item by --list.Count. Just don't forget to nullify the popped item if needed</summary>
    public int Count { get => _count; set => _count = value; }
    private int _count;

    /// <summary>Exposes the pool to rent and return the arrays</summary>
    public TPool Pool;

#pragma warning disable CS0649 // it is fine `Stack` is never assigned to, and will always have its default value
    /// <summary>Let's enable access to the stack, just know what's you doing</summary>
    public TStack Stack;
#pragma warning restore CS0649

    /// <summary>Exposes the rest on the heap</summary>
    public T[] Rest;

    /// <summary>Ensures that the list has allocated space to hold `count` of items</summary>
    [MethodImpl((MethodImplOptions)256)]
    public void InitCount(int count)
    {
        Debug.Assert(count >= 0, $"The input count may be 0 (which means the list is empty) or more, but not negative {count}");
        Debug.Assert(_count == 0, "Initial the count should be 0");

        // Add the StackCapacity empty space at the end, we may use it later for BuildToArray.
        // The actual source Capacity will be StackCapacity + count.
        var heapCount = count - Stack.Capacity;
        if (heapCount > 0)
            Rest = Pool.RentMinOrNew(heapCount);

        _count = count;
    }

    /// <summary>Returns a surely present item ref by its index</summary>
    [UnscopedRef]
    [MethodImpl((MethodImplOptions)256)]
    public ref T GetSurePresentRef(int index)
    {
        Debug.Assert(_count != 0, "List should not be empty");
        Debug.Assert(index >= 0 & index < _count, $"Index {index} should be less than Count {_count}");

        var stackCap = Stack.Capacity;
        if (index < stackCap)
            return ref Stack.GetSurePresentRef(index);

        Debug.Assert(Rest != null);
        return ref Rest.GetSurePresentRef(index - stackCap);
    }

    /// <summary>Returns surely present item by ref</summary>
    [UnscopedRef]
    public ref T this[int index]
    {
        [MethodImpl((MethodImplOptions)256)]
        get
        {
            if (index < 0 | index >= _count)
                return ref SmallList.ThrowIndexOutOfBounds<T>(index, _count);

            var stackCap = Stack.Capacity;
            if (index < stackCap)
                return ref Stack.GetSurePresentRef(index);

            Debug.Assert(Rest != null, "Expecting deeper items are already existing on heap");
            return ref Rest.GetSurePresentRef(index - stackCap);
        }
    }

    /// <summary>Appends the default item to the end of the list and returns the reference to it.</summary>
    [UnscopedRef]
    [MethodImpl((MethodImplOptions)256)]
    public ref T AddDefaultAndGetRef()
    {
        var index = _count++;
        var stackCap = Stack.Capacity;
        if (index < stackCap)
            return ref Stack.GetSurePresentRef(index);
        return ref SmallList.AddDefaultAndGetRef(ref Rest, ref Pool, index - stackCap);
    }

    /// <summary>Adds the item to the end of the list aka the Stack.Push. Returns the index of the added item.</summary>
    [MethodImpl((MethodImplOptions)256)]
    public int Add(in T item)
    {
        var index = _count++;
        var stackCap = Stack.Capacity;
        if (index < stackCap)
            Stack.GetSurePresentRef(index) = item;
        else
            SmallList.AddDefaultAndGetRef(ref Rest, ref Pool, index - stackCap) = item;
        return index;
    }

    /// <summary>Looks for the item in the list and return its index if found or -1 for the absent item</summary>
    [MethodImpl((MethodImplOptions)256)]
    public int TryGetIndex<TEq>(in T item, TEq eq = default) where TEq : struct, IEq<T>
    {
        if (_count != 0)
        {
            var index = 0;
            foreach (var it in this)
            {
                if (eq.Equals(item, it))
                    return index;
                ++index;
            }
        }
        return -1;
    }

    /// <summary>Returns the index of the found item or appends the item to the end of the list, and returns its index</summary>
    [MethodImpl((MethodImplOptions)256)]
    public int GetIndexOrAdd<TEq>(in T item, TEq eq = default) where TEq : struct, IEq<T>
    {
        var i = TryGetIndex(in item, eq);
        return i != -1 ? i : Add(in item);
    }

    ///<summary>Clears the list, but keeps the already allocated array on heap to reuse in the future</summary>
    [MethodImpl((MethodImplOptions)256)]
    public void Clear()
    {
        Stack = default; // todo: @perf is there way to faster clear items on stack?
        var restCount = _count - Stack.Capacity;
        if (restCount > 0)
        {
            Debug.Assert(Rest != null, "Expecting deeper items are already existing on heap");
            Array.Clear(Rest, 0, restCount);
        }
        _count = 0;
    }

    /// <summary>Returns the Rest of the items to the pool</summary>
    [MethodImpl((MethodImplOptions)256)]
    public void FreePooled()
    {
        if (Rest != null)
        {
            var oldRest = Rest;
            Rest = null;
            Pool.ReuseIfPossible(oldRest);
        }
    }

    /// <summary>Returns last present item ref, assumes that the list is not empty!</summary>
    [UnscopedRef]
    [MethodImpl((MethodImplOptions)256)]
    public ref T GetLastSurePresentItem()
    {
        Debug.Assert(_count != 0, "Expecting that the list is not empty");
        return ref GetSurePresentRef(_count - 1);
    }

    /// <summary>Removes the last item from the list aka the Stack Pop. Assumes that the list is not empty!</summary>
    [MethodImpl((MethodImplOptions)256)]
    public void RemoveLastSurePresentItem()
    {
        Debug.Assert(_count != 0, "SmallList.RemoveLastSurePresentItem: Expecting that the list is not empty");
        GetSurePresentRef(_count - 1) = default;
        --_count;
    }

    /// <inheritdoc/>
    public void CopyToArray(T[] arr, int copyToIndex = 0)
    {
        if (_count == 0) return;

        Debug.Assert(arr != null, "Target array should not be null");
        Debug.Assert(arr.Length - copyToIndex >= _count,
            $"Target array is too small {arr.Length} to hold {_count} items starting from index {copyToIndex}");

        for (var i = 0; i < arr.Length; ++i)
            arr[copyToIndex + i] = Stack.GetSurePresentRef(i);

        var restCount = _count - Stack.Capacity;
        if (restCount > 0)
        {
            Debug.Assert(Rest != null && Rest.Length >= restCount, $"Expecting the Rest of {restCount} but found only {Rest?.Length.ToString() ?? "`null`"}");
            Array.Copy(Rest, 0, arr, copyToIndex + Stack.Capacity, restCount);
        }
    }

    /// <summary>Returns an enumerator struct</summary>
    [MethodImpl((MethodImplOptions)256)]
    public SmallListEnumerator<T, TStack> GetEnumerator() => new(Stack, Rest, _count);
    IEnumerator<T> IEnumerable<T>.GetEnumerator() => GetEnumerator();
    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
}

/// <summary>Enumerator on stack, without allocations</summary>
public struct SmallListEnumerator<T, TStack> : IEnumerator<T>, IEnumerator
    where TStack : struct, IStack<T, TStack>
{
    private readonly TStack _stack;
    private readonly T[] _rest;
    private readonly int _count;
    private int _index;
    internal SmallListEnumerator(TStack stack, T[] rest, int count)
    {
        _stack = stack;
        _rest = rest;
        _count = count;
        _index = -1;
    }

    private T _current;
    /// <inheritdoc />
    public T Current => _current;
    object IEnumerator.Current => _current;
    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public bool MoveNext()
    {
        var index = ++_index;
        if (index < _count)
        {
            _current = index < _stack.Capacity
                ? _stack.GetSurePresentRef(index)
                : _rest.GetSurePresentRef(index - _stack.Capacity);
            return true;
        }
        return false;
    }
    /// <inheritdoc />
    public void Reset() => _index = -1;
    /// <inheritdoc />
    public void Dispose() { }
}

/// <summary>Printable thing via provided printer </summary>
public interface IPrintable
{
    /// <summary>Print to the provided string builder via the provided printer.</summary>
    StringBuilder Print(StringBuilder s, Func<StringBuilder, object, StringBuilder> printer);
}

/// <summary>Produces good enough hash codes for the fields</summary>
public static class Hasher
{
    /// <summary>Combines hashes of two fields</summary>
    public static int Combine<T1, T2>(T1 a, T2 b)
    {
        var bh = b?.GetHashCode() ?? 0;
        if (ReferenceEquals(a, null))
            return bh;
        var ah = a.GetHashCode();
        if (ah == 0)
            return bh;
        return Combine(ah, bh);
    }

    /// <summary>Inspired by System.Tuple.CombineHashCodes</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static int Combine(int h1, int h2)
    {
        unchecked
        {
            return (h1 << 5) + h1 ^ h2;
        }
    }
}

/// <summary>Configures removed key tombstone, equality and hash function for the SmallMap and friends</summary>
public interface IEq<K> : IEqualityComparer<K>
{
    /// <summary>Defines the value of the key indicating the removed entry</summary>
    K GetTombstone();
}

/// <summary>Default comparer using the `object.GetHashCode` and `object.Equals` overloads</summary>
public struct DefaultEq<K> : IEq<K>
{
    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public K GetTombstone() => default;

    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public bool Equals(K x, K y) => ReferenceEquals(x, y) || x.Equals(y);

    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public int GetHashCode(K key) => key.GetHashCode();
}

/// <summary>Uses the integer itself as hash code and `==` for equality</summary>
public struct IntEq : IEq<int>
{
    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public int GetTombstone() => int.MinValue; // todo: @improve separate the tombstone from the hash

    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public bool Equals(int x, int y) => x == y;

    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public int GetHashCode(int key) => key;
}

/// <summary>Instances of the RefEq for the often used K</summary>
public static class RefEq
{
    /// <summary>RefEq for object, possibly the only thing you need</summary>
    public static readonly RefEq<object> OfObject = default;
}

// todo: @wip should we even need K here, maybe object implementation is enough?
/// <summary>Uses the `object.GetHashCode` and `object.ReferenceEquals`</summary>
public struct RefEq<K> : IEq<K> where K : class
{
    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public K GetTombstone() => null;

    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public bool Equals(K x, K y) => ReferenceEquals(x, y);

    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public int GetHashCode(K key) => RuntimeHelpers.GetHashCode(key);
}

/// <summary>Compares via `ReferenceEquals` and gets the hash faster via `RuntimeHelpers.GetHashCode`</summary>
public struct RefEq<A, B> : IEq<(A, B)>
    where A : class
    where B : class
{
    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public (A, B) GetTombstone() => (null, null);

    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public bool Equals((A, B) x, (A, B) y) =>
        ReferenceEquals(x.Item1, y.Item1) && ReferenceEquals(x.Item2, y.Item2);

    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public int GetHashCode((A, B) key) =>
        Hasher.Combine(RuntimeHelpers.GetHashCode(key.Item1), RuntimeHelpers.GetHashCode(key.Item2));
}

/// <summary>Compares via `ReferenceEquals` and gets the hash faster via `RuntimeHelpers.GetHashCode`</summary>
public struct RefEq<A, B, C> : IEq<(A, B, C)>
    where A : class
    where B : class
    where C : class
{
    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public (A, B, C) GetTombstone() => (null, null, null);

    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public bool Equals((A, B, C) x, (A, B, C) y) =>
        ReferenceEquals(x.Item1, y.Item1) && ReferenceEquals(x.Item2, y.Item2) && ReferenceEquals(x.Item3, y.Item3);

    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public int GetHashCode((A, B, C) key) =>
        Hasher.Combine(RuntimeHelpers.GetHashCode(key.Item1), Hasher.Combine(RuntimeHelpers.GetHashCode(key.Item2), RuntimeHelpers.GetHashCode(key.Item3)));
}

/// <summary>Add the Use parameter to `T Method{T}(..., Use{T} _)` to enable type inference for T,
/// by calling it as `var t = Method(..., default(Use{T}))`</summary>
public interface Use<T> { }

/// <summary>Configuration and the tools for the SmallMap and friends</summary>
public static class SmallMap
{
    internal const byte MinFreeCapacityShift = 3; // e.g. for the capacity 16: 16 >> 3 => 2, 12.5% of the free hash slots (it does not mean the entries free slot)
    internal const byte MinHashesCapacityBitShift = 3; // 1 << 3 == 8
    internal const byte DefaultHashesCapacityBitShift = 4; // 1 << 4 == 16, means the default capacity is 16 int hashes
    internal const int IndexMask = (1 << DefaultHashesCapacityBitShift) - 1; // 0b00000000000000000000000000001111
    /// <summary>Upper hash bits spent on storing the probes, e.g. 5 bits mean 31 probes max.</summary>
    public const byte ProbeBits = 5;
    internal const byte NotShiftedProbeCountMask = (1 << ProbeBits) - 1; // 0b00000000000000000000000000011111
    // 27, so the upper 5 bits are used for the probe count
    internal const byte ProbeCountShift = 32 - ProbeBits;
    // ~0b11111000000000000000000000000000 -> 0b00000111111111111111111111111111
    internal const int HashAndIndexMask = ~(NotShiftedProbeCountMask << ProbeCountShift);
    // Window with the hash mask without the lead ProbeMask and closing IndexMask 0b00000111111111111111111111110000
    internal const int HashMask = HashAndIndexMask & ~IndexMask;

    /// <summary>Represent a keyed entry stored in the SmallMap.
    /// Its implementation struct may include the additional Value for the Map or just the Key for the Set.
    /// The implementation may also decide to make Value readonly or writable for the in-place update</summary>
    public interface IEntry<K>
    {
        /// <summary>Returns the key of the payload</summary>
        K Key { get; internal set; }
    }

    /// <summary>Holds a single entry consisting of key and value. 
    /// Value may be set or changed but the key is set in stone (by construction).</summary>
    [DebuggerDisplay("{Key?.ToString()}->{Value}")]
    public struct Entry<K, V> : IEntry<K>
    {
        /// <summary>The readonly key</summary>
        public K Key { get; set; }
        /// <summary>The mutable value</summary>
        public V Value;
        /// <summary>Construct with the key and default value</summary>
        public Entry(K key) => Key = key;
        /// <summary>Construct with the key and value</summary>
        public Entry(K key, V value)
        {
            Key = key;
            Value = value;
        }
    }

    /// <summary>The entry with just a key.
    /// When used with the SmallMap it may represent a Set without wasting the space for the absent value</summary>
    [DebuggerDisplay("{Key?.ToString()}")]
    public struct Entry<K> : IEntry<K>
    {
        /// <summary>The readonly key</summary>
        public K Key { get; set; }
        /// <summary>Construct with the key and default value</summary>
        public Entry(K key) => Key = key;
    }

    /// <summary>Binary representation of the `int`</summary>
    public static string ToB(int x) => System.Convert.ToString(x, 2).PadLeft(32, '0');

    /// <summary>Abstraction to configure your own entries data structure. Check the derived types for the examples</summary>
    public interface IEntries<K, TEntry, TEq>
        where TEntry : struct, IEntry<K>
        where TEq : IEq<K>
    {
        /// <summary>Initializes the entries storage to the specified capacity</summary>
        void Init(int capacityPowerOfTwoPlease);

        /// <summary>Returns the reference to entry by its index, index should map to the present/non-removed entry</summary>
        ref TEntry GetSurePresentEntryRef(int index);

        /// <summary>Adds the key at the "end" of entries - so the order of addition is preserved.</summary>
        ref TEntry AddKeyAndGetEntryRef(K key, int index);
    }

    internal const int MinEntriesCapacity = 2;

    /// <summary>For now to use in the Set as a value</summary>
    public readonly struct NoValue { }

    /// <summary>Stores the entries in a single dynamically reallocated growing array</summary>
    [DebuggerDisplay("{Capacity:_entries?.Length ?? 0} of {_entries?[0]}, {_entries?[1]}, ...")]
    public struct SingleArrayEntries<K, TEntry, TEq> : IEntries<K, TEntry, TEq>
        where TEntry : struct, IEntry<K>
        where TEq : struct, IEq<K>
    {
        internal TEntry[] _entries;

        /// <inheritdoc/>
        public void Init(int capacityPowerOfTwoPlease) =>
            _entries = new TEntry[capacityPowerOfTwoPlease];

        /// <inheritdoc/>
        [MethodImpl((MethodImplOptions)256)]
        public ref TEntry GetSurePresentEntryRef(int index) =>
            ref _entries.GetSurePresentRef(index);

        /// <inheritdoc/>
        [MethodImpl((MethodImplOptions)256)]
        public ref TEntry AddKeyAndGetEntryRef(K key, int index)
        {
            if (index == _entries.Length)
                Array.Resize(ref _entries, index << 1);

            ref var e = ref _entries.GetSurePresentRef(index);
            e.Key = key;
            return ref e;
        }
    }

    /// <summary>Lookup for the K in the TStackEntries, first by calculating it hash with TEq and searching the hash in the TStackHashes</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref TEntry TryGetEntryRef<K, TEntry, TEq, TCap, TStackHashes, TStackEntries>(
        this ref TStackEntries entries, ref TStackHashes hashes, int count, K key, out bool found,
        TEq eq = default, TCap cap = default, Use<TEntry> _ = default)
        where TEntry : struct, IEntry<K>
        where TEq : struct, IEq<K>
        where TStackHashes : struct, IStack<int, TCap, TStackHashes>
        where TStackEntries : struct, IStack<TEntry, TCap, TStackEntries>
        where TCap : struct, ISize2Plus
    {
        Debug.Assert(count <= cap.Size, $"SmallMap.TryGetEntryRef: count {count} should be <= stack capacity {cap.Size}");

        var hash = eq.GetHashCode(key);

#if NET8_0_OR_GREATER
        if (count >= 8 & cap.Size >= 8 & Vector256.IsHardwareAccelerated)
        {
            var vHash = Vector256.Create(hash);
            var vHashes = MemoryMarshal.Cast<int, Vector256<int>>(hashes.AsSpan());
            var i = 0;
            foreach (var vCurr in vHashes)
            {
                var vMatches = Vector256.Equals(vCurr, vHash);
                var matches = Vector256.ExtractMostSignificantBits(vMatches);
                while (matches != 0)
                {
                    var matchIndex = System.Numerics.BitOperations.TrailingZeroCount(matches);

                    ref var entry = ref entries.GetSurePresentRef(i + matchIndex);
                    if (found = eq.Equals(entry.Key, key))
                        return ref entry;

                    // Clear lower bits up to and including the first set bit, afaik it can be hw accelerated 
                    // 0b0001_1000 & (0b0001_1000 - 1) -> & 0b0001_1000 & 0b0001_0111 -> 0b0001_0000 
                    matches &= matches - 1;
                }

                i += Vector256<int>.Count;
                if (i >= count)
                    break;
            }

            found = false;
            return ref RefTools<TEntry>.GetNullRef();
        }
#endif

        for (var i = 0; i < count; ++i)
        {
            var h = hashes.GetSurePresentRef(i);
            if (h == hash)
            {
                ref var entry = ref entries.GetSurePresentRef(i);
                if (found = eq.Equals(entry.Key, key))
                    return ref entry;
            }
        }

        found = false;
        return ref RefTools<TEntry>.GetNullRef();
    }

    /// <summary>Gets the ref to the existing entry.Value by the provided key (found == true),
    /// or adds a new entry (found == false) and returns it.Value by ref. 
    /// So the method always return a non-null ref to the value, either existing or added</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref V AddOrGetValueRef<K, V, TEq, TStackCap, TStackHashes, TStackEntries, TEntries>(
        this ref SmallMap<K, Entry<K, V>, TEq, TStackCap, TStackHashes, TStackEntries, TEntries> map, K key, out bool found)
        where TEq : struct, IEq<K>
        where TStackCap : struct, ISize2Plus
        where TStackHashes : struct, IStack<int, TStackCap, TStackHashes>
        where TStackEntries : struct, IStack<Entry<K, V>, TStackCap, TStackEntries>
        where TEntries : struct, IEntries<K, Entry<K, V>, TEq> =>
        ref map.AddOrGetEntryRef(key, out found).Value;

    /// <summary>Adds an entry for sure absent key.
    /// Provides the performance in scenarios where you look for the present key, and using it, and if ABSENT then add the new one.
    /// So this method optimized NOT to look for the present item for the second time</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref V AddSureAbsentDefaultAndGetRef<K, V, TEq, TStackCap, TStackHashes, TStackEntries, TEntries>(
        this ref SmallMap<K, Entry<K, V>, TEq, TStackCap, TStackHashes, TStackEntries, TEntries> map, K key)
        where TEq : struct, IEq<K>
        where TStackCap : struct, ISize2Plus
        where TStackHashes : struct, IStack<int, TStackCap, TStackHashes>
        where TStackEntries : struct, IStack<Entry<K, V>, TStackCap, TStackEntries>
        where TEntries : struct, IEntries<K, Entry<K, V>, TEq>
        => ref map.AddSureAbsentDefaultEntryAndGetRef(key).Value;

    /// <summary>Lookups for the stored entry by key. Returns the ref to the found entry.Value or the null ref</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref V TryGetValueRef<K, V, TEq, TStackCap, TStackHashes, TStackEntries, TEntries>(
        this ref SmallMap<K, Entry<K, V>, TEq, TStackCap, TStackHashes, TStackEntries, TEntries> map, K key, out bool found)
        where TEq : struct, IEq<K>
        where TStackCap : struct, ISize2Plus
        where TStackHashes : struct, IStack<int, TStackCap, TStackHashes>
        where TStackEntries : struct, IStack<Entry<K, V>, TStackCap, TStackEntries>
        where TEntries : struct, IEntries<K, Entry<K, V>, TEq>
    {
        ref var e = ref map.TryGetEntryRef(key, out found);
        if (found) return ref e.Value;
        return ref RefTools<V>.GetNullRef();
    }
}

// todo: @improve ? how/where to add SIMD to improve CPU utilization but not losing perf for smaller sizes
/// <summary>
/// Fast and less-allocating hash map without thread safety nets. Please measure it in your own use case before use.
/// It is configurable in regard of hash calculation/equality via `TEq` type parameter and 
/// in regard of key-value storage via `TEntries` type parameter.
/// 
/// Details:
/// - Implemented as a struct so that the empty/default map does not allocate on heap
/// - Hashes and key-values are the separate collections enabling better cash locality and faster performance (data-oriented design)
/// - No SIMD for now to avoid complexity and costs for the smaller maps, so the map is more fit for the smaller sizes.
/// - Provides the "stable" enumeration of the entries in the added order
/// - The TryRemove method removes the hash but replaces the key-value entry with the tombstone key and the default value.
/// For instance, for the `RefEq` the tombstone is <see langword="null"/>. You may redefine it in the `IEq{K}.GetTombstone()` implementation.
/// 
/// </summary>
public struct SmallMap<K, TEntry, TEq, TStackCap, TStackHashes, TStackEntries, TEntries>
    where TEntry : struct, IEntry<K>
    where TEq : struct, IEq<K>
    where TStackCap : struct, ISize2Plus
    where TStackHashes : struct, IStack<int, TStackCap, TStackHashes>
    where TStackEntries : struct, IStack<TEntry, TStackCap, TStackEntries>
    where TEntries : struct, IEntries<K, TEntry, TEq>
{
    internal byte _capacityBitShift;
    internal int _count;

    // The _packedHashesAndIndexes elements are of `Int32` with the bits split as following:
    // 00010|000...110|01101
    // |     |         |- The index into the _entries structure, 0-based. The index bit count (indexMask) is the hashes capacity - 1.
    // |     |         | This part of the erased hash is used to get the ideal index into the hashes array, so later this part of hash may be restored from the hash index and its probes.
    // |     |- The remaining middle bits of the original hash
    // |- 5 (MaxProbeBits) high bits of the Probe count, with the minimal value of b00001 indicating the non-empty slot.
    internal int[] _packedHashesAndIndexes;

#pragma warning disable IDE0044 // it tries to make entries readonly but they should stay modify-able to prevent its defensive struct copying
#pragma warning disable CS0649 // field is never assigned to, and will always have its default value
    internal TEntries _entries;
    internal TStackHashes _stackHashes;
    internal TStackEntries StackEntries;
#pragma warning restore CS0649
#pragma warning restore IDE0044

    /// <summary>Capacity bits</summary>
    public int CapacityBitShift => _capacityBitShift;

    /// <summary>Access to the hashes and indexes</summary>
    public int[] PackedHashesAndIndexes => _packedHashesAndIndexes;

    /// <summary>Number of entries in the map</summary>
    public int Count => _count;

    /// <summary>Access to the key-value entries</summary>
    public TEntries Entries => _entries;

    /// <summary>Capacity calculates as `1 leftShift capacityBitShift`</summary>
    public SmallMap(byte capacityBitShift)
    {
        // Keep the capacity at least 8 for SIMD Vector256, etc., etc, if you need less space use Stack for that
        _capacityBitShift = capacityBitShift < MinHashesCapacityBitShift ? MinHashesCapacityBitShift : capacityBitShift;

        // The overflow tail to the hashes is the size of log2N where N==capacityBitShift, 
        // it is probably fine to have the check for the overflow of capacity because it will be mis-predicted only once at the end of loop (it even rarely for the lookup)
        _packedHashesAndIndexes = new int[1 << capacityBitShift];
        _entries.Init(capacityBitShift);
    }

    ///<summary>Get the value ref by the entry index. Also the index corresponds to entry adding order.
    /// Important: it does not check the index bounds, so you need to check that the index is from 0 to map.Count-1</summary>
    [UnscopedRef]
    [MethodImpl((MethodImplOptions)256)]
    public ref TEntry GetSurePresentEntryRef(int index)
    {
        Debug.Assert(index >= 0);
        Debug.Assert(index < _count);
        if (index >= StackEntries.Capacity)
            return ref _entries.GetSurePresentEntryRef(index - StackEntries.Capacity);
        return ref StackEntries.GetSurePresentRef(index);
    }

    [UnscopedRef]
    private ref TEntry AddOrGetRefInEntries(K key, out bool found)
    {
        // if the free space is less than 1/8 of capacity (12.5%) then Resize
        var indexMask = (1 << _capacityBitShift) - 1;
        if (indexMask - _count <= (indexMask >>> MinFreeCapacityShift))
            indexMask = ResizeHashes(indexMask);

        var hash = default(TEq).GetHashCode(key);
        var hashMiddleMask = HashAndIndexMask & ~indexMask;
        var hashMiddle = hash & hashMiddleMask;
        var hashIndex = hash & indexMask;

#if NET7_0_OR_GREATER
        ref var hashesAndIndexes = ref MemoryMarshal.GetArrayDataReference(_packedHashesAndIndexes);
#else
        ref var hashesAndIndexes = ref _packedHashesAndIndexes;
#endif
        ref var h = ref hashesAndIndexes.GetSurePresentRef(hashIndex);

        // 1. Skip over hashes with the bigger and equal probes. The hashes with bigger probes overlapping from the earlier ideal positions
        var probe = 1;
        while ((h >>> ProbeCountShift) >= probe)
        {
            // 2. For the equal probes check for equality the hash middle part, and update the entry if the keys are equal too 
            if (((h >>> ProbeCountShift) == probe) & ((h & hashMiddleMask) == hashMiddle))
            {
                ref var e = ref GetSurePresentEntryRef(h & indexMask);
                if (found = default(TEq).Equals(e.Key, key))
                    return ref e;
            }
            h = ref hashesAndIndexes.GetSurePresentRef(++hashIndex & indexMask);
            ++probe;
        }
        found = false;

        // 3. We did not find the hash and therefore the key, so insert the new entry
        var hRobinHooded = h;
        h = (probe << ProbeCountShift) | hashMiddle | _count;

        // 4. If the robin hooded hash is empty then we stop
        // 5. Otherwise we steal the slot with the smaller probes
        probe = hRobinHooded >>> ProbeCountShift;
        while (hRobinHooded != 0)
        {
            h = ref hashesAndIndexes.GetSurePresentRef(++hashIndex & indexMask);
            if ((h >>> ProbeCountShift) < ++probe)
            {
                var tmp = h;
                h = (probe << ProbeCountShift) | (hRobinHooded & HashAndIndexMask);
                hRobinHooded = tmp;
                probe = hRobinHooded >>> ProbeCountShift;
            }
        }

        return ref _entries.AddKeyAndGetEntryRef(key, (_count++) - StackEntries.Capacity);
    }

    private void AddJustHashAndEntryIndexWithoutResizing(int hash, int index)
    {
        var hashIndex = hash & IndexMask;

#if NET7_0_OR_GREATER
        ref var hashesAndIndexes = ref MemoryMarshal.GetArrayDataReference(_packedHashesAndIndexes);
#else
        var hashesAndIndexes = _packedHashesAndIndexes;
#endif
        // 1. Skip over hashes with the bigger and equal probes. The hashes with bigger probes overlapping from the earlier ideal positions
        ref var h = ref hashesAndIndexes.GetSurePresentRef(hashIndex);
        var probe = 1;
        while ((h >>> ProbeCountShift) >= probe)
        {
            h = ref hashesAndIndexes.GetSurePresentRef(++hashIndex & IndexMask);
            ++probe;
        }

        // 3. We did not find the hash and therefore the key, so insert the new entry
        var hRobinHooded = h;
        h = (probe << ProbeCountShift) | (hash & HashMask) | index;

        // 4. If the robin hooded hash is empty then we stop
        // 5. Otherwise we steal the slot with the smaller probes
        probe = hRobinHooded >>> ProbeCountShift;
        while (hRobinHooded != 0)
        {
            h = ref hashesAndIndexes.GetSurePresentRef(++hashIndex & IndexMask);
            if ((h >>> ProbeCountShift) < ++probe)
            {
                var tmp = h;
                h = (probe << ProbeCountShift) | (hRobinHooded & HashAndIndexMask);
                hRobinHooded = tmp;
                probe = hRobinHooded >>> ProbeCountShift;
            }
        }
    }

    /// <summary>Gets the ref to the existing entry by the provided key (found == true),
    /// or adds a new entry (found == false) and returns it by ref</summary>
    [UnscopedRef]
    public ref TEntry AddOrGetEntryRef(K key, out bool found)
    {
        if (_count > StackEntries.Capacity)
            return ref AddOrGetRefInEntries(key, out found);

        ref var e = ref StackEntries.TryGetEntryRef(ref _stackHashes, _count, key, out found,
            default(TEq), default(TStackCap), default(Use<TEntry>));
        if (found)
            return ref e;

        // Add the new entry to the stack if there is still space in stack
        if (_count < StackEntries.Capacity)
        {
            var newIndex = _count++;
            _stackHashes.GetSurePresentRef(newIndex) = default(TEq).GetHashCode(key);
            ref var newEntry = ref StackEntries.GetSurePresentRef(newIndex);
            newEntry.Key = key;
            return ref newEntry;
        }

        // Now all capacity of the stack is used.
        // To avoid double work always going linearly through the Stack with the comparison,
        // let's calculate the hash of the keys stored on stack and put them 
        // to the usual HashMap packed hashes and indexes array for the promised O(1) lookup.
        // But the values are remaining on the Stack, and for the found index of the entry we use the GetSurePresentRef(index) 
        // to get the value reference either from the Stack or the Entries.
        // So the values on the stack are guarantied to be stable from the beginning of the map creation, 
        // because they are not copied when the Entries need to Resize (depending on the TEntries implementation). 

        _capacityBitShift = DefaultHashesCapacityBitShift;
        _packedHashesAndIndexes = new int[1 << DefaultHashesCapacityBitShift];

        for (var i = 0; i < StackEntries.Capacity; ++i)
            AddJustHashAndEntryIndexWithoutResizing(default(TEq).GetHashCode(GetSurePresentEntryRef(i).Key), i);

        AddJustHashAndEntryIndexWithoutResizing(default(TEq).GetHashCode(key), StackEntries.Capacity);

        _count = StackEntries.Capacity + 1; // +1 because we added the new key
        _entries.Init(StackEntries.Capacity); // Give the heap entries the same initial capacity as Stack, effectively doubling the capacity
        return ref _entries.AddKeyAndGetEntryRef(key, 0); // add the new key to the entries with the 0 index in the entries
    }

    /*
    Insertion step by step:

    1. Initially the map is empty. Its capacity mask is 7:

    Index:  0    1    2    3    4    5    6    7
    Hash:  [0]  [0]  [0]  [0]  [0]  [0]  [0]  [0]

    2. Insert the key A with the hash 13, which is 0b0011_0101. 13 & 7 Mask = 5, so the index is 5.

    Index:  0    1    2    3    4    5    6    7
    Hash:  [0]  [0]  [0]  [0]  [0]  [13] [0]  [0]
    Probe:                           1A

    3. Insert the key B with the hash 5, which is 0b0000_1011. 5 & 7 Mask = 5, so the index is again 5.

    Index:  0    1    2    3    4    5    6    7
    Hash:  [0]  [0]  [0]  [0]  [0]  [13] [5]  [0]
    Probe                            1A   2B

    4. Insert the key C with the hash 7, which is 0b0010_0101. 7 & 7 Mask = 7, so the index is 7.

    Index:  0    1    2    3    4    5    6    7
    Hash:  [0]  [0]  [0]  [0]  [0]  [13] [5]  [7]
    Probe:                           1A   2B   1C

    5. Insert the key D with the hash 21, which is 0b0101_0101. 21 & 7 Mask = 5, so the index is again again 5.

    Index:  0    1    2    3    4    5    6    7
    Hash:  [7]  [0]  [0]  [0]  [0]  [13] [5]  [21]
    Probe:  2C                       1A   2B   3D
    */
    [UnscopedRef]
    private ref TEntry AddSureAbsentDefaultAndGetRefInEntries(K key)
    {
        // if the free space is less than 1/8 of capacity (12.5%) then Resize
        var indexMask = (1 << _capacityBitShift) - 1;
        if (indexMask - _count <= (indexMask >>> MinFreeCapacityShift))
            indexMask = ResizeHashes(indexMask);

        var hash = default(TEq).GetHashCode(key);
        var hashIndex = hash & indexMask;

#if NET7_0_OR_GREATER
        ref var hashesAndIndexes = ref MemoryMarshal.GetArrayDataReference(_packedHashesAndIndexes);
#else
        var hashesAndIndexes = _packedHashesAndIndexes;
#endif
        ref var h = ref hashesAndIndexes.GetSurePresentRef(hashIndex);

        // 1. Skip over hashes with the bigger and equal probes. The hashes with bigger probes overlapping from the earlier ideal positions
        var probe = 1;
        while ((h >>> ProbeCountShift) >= probe)
        {
            h = ref hashesAndIndexes.GetSurePresentRef(++hashIndex & indexMask);
            ++probe;
        }

        // 3. We did not find the hash and therefore the key, so insert the new entry
        var hRobinHooded = h;
        h = (probe << ProbeCountShift) | (hash & HashAndIndexMask & ~indexMask) | _count;

        // 4. If the robin hooded hash is empty then we stop
        // 5. Otherwise we steal the slot with the smaller probes
        probe = hRobinHooded >>> ProbeCountShift;
        while (hRobinHooded != 0)
        {
            h = ref hashesAndIndexes.GetSurePresentRef(++hashIndex & indexMask);
            if ((h >>> ProbeCountShift) < ++probe)
            {
                var tmp = h;
                h = (probe << ProbeCountShift) | (hRobinHooded & HashAndIndexMask);
                hRobinHooded = tmp;
                probe = hRobinHooded >>> ProbeCountShift;
            }
        }

        return ref _entries.AddKeyAndGetEntryRef(key, (_count++) - StackEntries.Capacity);
    }

    /// <summary>Adds an entry for sure absent key.
    /// Provides the performance in scenarios where you look for the present key, and using it, and if ABSENT then add the new one.
    /// So this method optimized NOT to look for the present item for the second time</summary>
    [UnscopedRef]
    public ref TEntry AddSureAbsentDefaultEntryAndGetRef(K key)
    {
        if (_count > StackEntries.Capacity)
            return ref AddSureAbsentDefaultAndGetRefInEntries(key);

        // Add the new entry to the stack if there is still space in stack
        if (_count < StackEntries.Capacity)
        {
            var newIndex = _count++;
            _stackHashes.GetSurePresentRef(newIndex) = default(TEq).GetHashCode(key);
            ref var newEntry = ref StackEntries.GetSurePresentRef(newIndex);
            newEntry.Key = key;
            return ref newEntry;
        }

        _capacityBitShift = DefaultHashesCapacityBitShift;
        _packedHashesAndIndexes = new int[1 << DefaultHashesCapacityBitShift];

        for (var i = 0; i < StackEntries.Capacity; ++i)
            AddJustHashAndEntryIndexWithoutResizing(default(TEq).GetHashCode(GetSurePresentEntryRef(i).Key), i);

        AddJustHashAndEntryIndexWithoutResizing(default(TEq).GetHashCode(key), StackEntries.Capacity);

        _count = StackEntries.Capacity + 1; // +1 because we added the new key
        _entries.Init(StackEntries.Capacity); // Give the heap entries the same initial capacity as Stack, effectively doubling the capacity
        return ref _entries.AddKeyAndGetEntryRef(key, 0); // add the new key to the entries with the 0 index in the entries
    }

    /// <summary>Lookups for the stored key. If found true, otherwise false</summary>
    public bool ContainsKey(K key)
    {
        if (_count > StackEntries.Capacity)
        {
            _ = TryGetRefInEntries(key, out var found);
            return found;
        }
        else
        {
            _ = ref StackEntries.TryGetEntryRef(ref _stackHashes, _count, key, out var found,
                default(TEq), default(TStackCap), default(Use<TEntry>));
            return found;
        }
    }

    [UnscopedRef]
    [MethodImpl((MethodImplOptions)256)]
    internal ref TEntry TryGetRefInEntries(K key, out bool found)
    {
        var hash = default(TEq).GetHashCode(key);

        var indexMask = (1 << _capacityBitShift) - 1;
        var hashMiddleMask = HashAndIndexMask & ~indexMask;
        var hashMiddle = hash & hashMiddleMask;
        var hashIndex = hash & indexMask;

#if NET7_0_OR_GREATER
        ref var hashesAndIndexes = ref MemoryMarshal.GetArrayDataReference(_packedHashesAndIndexes);
#else
        var hashesAndIndexes = _packedHashesAndIndexes;
#endif

        var h = hashesAndIndexes.GetSurePresent(hashIndex);

        // 1. Skip over hashes with the bigger and equal probes. The hashes with bigger probes overlapping from the earlier ideal positions
        var probe = 1;
        while ((h >>> ProbeCountShift) >= probe)
        {
            // 2. For the equal probes check for equality the hash middle part, and update the entry if the keys are equal too 
            if (((h >>> ProbeCountShift) == probe) & ((h & hashMiddleMask) == hashMiddle))
            {
                ref var e = ref GetSurePresentEntryRef(h & indexMask);
                if (found = default(TEq).Equals(e.Key, key))
                    return ref e;
            }

            h = hashesAndIndexes.GetSurePresent(++hashIndex & indexMask);
            ++probe;
        }

        found = false;
        return ref RefTools<TEntry>.GetNullRef();
    }

    // todo: @wip @remove
    [UnscopedRef]
    [MethodImpl((MethodImplOptions)256)]
    internal ref TEntry TryGetRefInEntries2(K key, out bool found)
    {
        var hash = default(TEq).GetHashCode(key);

        var indexMask = (1 << _capacityBitShift) - 1;
        var hashMiddleMask = HashAndIndexMask & ~indexMask;
        var hashMiddle = hash & hashMiddleMask;
        var hashIndex = hash & indexMask;

#if NET7_0_OR_GREATER
        ref var hashesAndIndexes = ref MemoryMarshal.GetArrayDataReference(_packedHashesAndIndexes);
#else
        var hashesAndIndexes = _packedHashesAndIndexes;
#endif

        var h = hashesAndIndexes.GetSurePresent(hashIndex);

        // 1. Skip over hashes with the bigger and equal probes. The hashes with bigger probes overlapping from the earlier ideal positions
        var probe = 1;

        while ((h >>> ProbeCountShift) >= probe)
        {
            // 2. For the equal probes check for equality the hash middle part, then check the entry
            if (((h >>> ProbeCountShift) == probe) & ((h & hashMiddleMask) == hashMiddle))
            {
                ref var e = ref GetSurePresentEntryRef(h & indexMask);
                if (found = default(TEq).Equals(e.Key, key))
                    return ref e;
            }

            h = hashesAndIndexes.GetSurePresent(++hashIndex & indexMask);
            ++probe;
        }

        found = false;
        return ref RefTools<TEntry>.GetNullRef();
    }

    /// <summary>Lookup for the stored entry by key. Returns the ref to the found entry or the null ref</summary>
    [UnscopedRef]
    public ref TEntry TryGetEntryRef(K key, out bool found)
    {
        if (_count > StackEntries.Capacity)
            return ref TryGetRefInEntries(key, out found);
        return ref StackEntries.TryGetEntryRef(ref _stackHashes, _count, key, out found,
            default(TEq), default(TStackCap), default(Use<TEntry>));
    }

    internal int ResizeHashes(int indexMask)
    {
        var oldCapacity = indexMask + 1;
        var newHashAndIndexMask = HashAndIndexMask & ~oldCapacity;
        var newIndexMask = (indexMask << 1) | 1;

        var newHashesAndIndexes = new int[oldCapacity << 1];

#if NET7_0_OR_GREATER
        ref var newHashes = ref MemoryMarshal.GetArrayDataReference(newHashesAndIndexes);
        ref var oldHashes = ref MemoryMarshal.GetArrayDataReference(_packedHashesAndIndexes);
        var oldHash = oldHashes;
#else
        var newHashes = newHashesAndIndexes;
        var oldHashes = _packedHashesAndIndexes;
        var oldHash = oldHashes[0];
#endif
        // Overflow segment is wrapped-around hashes and! the hashes at the beginning robin hooded by the wrapped-around hashes
        var i = 0;
        while ((oldHash >>> ProbeCountShift) > 1)
            oldHash = oldHashes.GetSurePresent(++i);

        var oldCapacityWithOverflowSegment = i + oldCapacity;
        while (true)
        {
            if (oldHash != 0)
            {
                // get the new hash index from the old one with the next bit equal to the `oldCapacity`
                var indexWithNextBit = (oldHash & oldCapacity) | (((i + 1) - (oldHash >>> ProbeCountShift)) & indexMask);

                // no need for robin-hooding because we already did it for the old hashes and now just filling the hashes into the new array which are already in order
                var probe = 1;
                ref var newHash = ref newHashes.GetSurePresentRef(indexWithNextBit);
                while (newHash != 0)
                {
                    newHash = ref newHashes.GetSurePresentRef(++indexWithNextBit & newIndexMask);
                    ++probe;
                }
                newHash = (probe << ProbeCountShift) | (oldHash & newHashAndIndexMask);
            }
            if (++i >= oldCapacityWithOverflowSegment)
                break;

            oldHash = oldHashes.GetSurePresent(i & indexMask);
        }
        ++_capacityBitShift;
        _packedHashesAndIndexes = newHashesAndIndexes;
        return newIndexMask;
    }
}

/// <summary>Holds the Map with 4 items on stack. Minimizes the number of type arguments required to be specified</summary>
public struct SmallMap4<K, V, TEq>() where TEq : struct, IEq<K>
{
    /// <summary>Map with 4 elements on stack and entries baked by the single array</summary> 
    public SmallMap<K, SmallMap.Entry<K, V>, TEq, Size4, Stack4<int>, Stack4<SmallMap.Entry<K, V>>, SmallMap.SingleArrayEntries<K, SmallMap.Entry<K, V>, TEq>> Map;
}

/// <summary>Holds the Map with 8 items on stack. Minimizes the number of type arguments required to be specified</summary>
public struct SmallMap8<K, V, TEq>() where TEq : struct, IEq<K>
{
    /// <summary>Map with 8 elements on stack and entries baked by the single array</summary> 
    public SmallMap<K, SmallMap.Entry<K, V>, TEq, Size8, Stack8<int>, Stack8<SmallMap.Entry<K, V>>, SmallMap.SingleArrayEntries<K, SmallMap.Entry<K, V>, TEq>> Map;
}

/// <summary>Holds the Map with 16 items on stack. Minimizes the number of type arguments required to be specified</summary>
public struct SmallMap16<K, V, TEq>() where TEq : struct, IEq<K>
{
    /// <summary>Map with 16 elements on stack and entries baked by the single array</summary> 
    public SmallMap<K, SmallMap.Entry<K, V>, TEq, Size16, Stack16<int>, Stack16<SmallMap.Entry<K, V>>, SmallMap.SingleArrayEntries<K, SmallMap.Entry<K, V>, TEq>> Map;
}

/// <summary>Holds the Set with 4 items on stack. Minimizes the number of type arguments required to be specified</summary>
public struct SmallSet4<K, TEq>() where TEq : struct, IEq<K>
{
    /// <summary>Set with 4 keys on stack and entries baked by the single array</summary> 
    public SmallMap<K, SmallMap.Entry<K>, TEq, Size4, Stack4<int>, Stack4<SmallMap.Entry<K>>, SmallMap.SingleArrayEntries<K, SmallMap.Entry<K>, TEq>> Set;
}

/// <summary>Holds the Set with 8 items on stack. Minimizes the number of type arguments required to be specified</summary>
public struct SmallSet8<K, TEq>() where TEq : struct, IEq<K>
{
    /// <summary>Set with 8 keys on stack and entries baked by the single array</summary> 
    public SmallMap<K, SmallMap.Entry<K>, TEq, Size8, Stack8<int>, Stack8<SmallMap.Entry<K>>, SmallMap.SingleArrayEntries<K, SmallMap.Entry<K>, TEq>> Set;
}

/// <summary>Holds the Set with 16 items on stack. Minimizes the number of type arguments required to be specified</summary>
public struct SmallSet16<K, TEq>() where TEq : struct, IEq<K>
{
    /// <summary>Set with 16 keys on stack and entries baked by the single array</summary> 
    public SmallMap<K, SmallMap.Entry<K>, TEq, Size16, Stack16<int>, Stack16<SmallMap.Entry<K>>, SmallMap.SingleArrayEntries<K, SmallMap.Entry<K>, TEq>> Set;
}
