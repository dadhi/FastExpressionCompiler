// <auto-generated/>
/*
The MIT License (MIT)

Copyright (c) 2016-2025 Maksim Volkau

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included 
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

// ReSharper disable once InconsistentNaming
#nullable disable

#if LIGHT_EXPRESSION
namespace FastExpressionCompiler.LightExpression.ImTools;
#else
namespace FastExpressionCompiler.ImTools;
#endif

using System;
using System.Collections;
using System.Collections.Generic;
using System.Diagnostics;
using System.Text;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Diagnostics.CodeAnalysis;

#if NETSTANDARD2_0_OR_GREATER || NET472
using System.Reflection.Emit;
using System.Reflection;
#endif

using static SmallMap4;

/// <summary>Helpers and polyfills for the missing things in the old .NET versions</summary>
public static class RefTools<T>
{
    /// <summary>Polyfill for the missing returning the `ref` in the failed search scenario.
    /// Note that the result is the `null` even for the struct `T`, so avoid the accessing its members without the check</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref T GetNullRef() =>
#if NET6_0_OR_GREATER
           ref Unsafe.NullRef<T>();
#else
        ref _missing;
    internal static T _missing = default;
#endif
}

/// <summary>Wrapper for the array of the specific capacity and a separate count less or equal to this capacity </summary>
public struct SmallList<T>
{
    /// <summary>Array of items</summary>
    public T[] Items;
    /// <summary>The count of used items</summary>
    public int Count;

    /// <summary>Creating this stuff</summary>
    public SmallList(T[] items, int count)
    {
        Items = items;
        Count = count;
    }

    /// <summary>Creates the wrapper out of the items</summary>
    public SmallList(T[] items) : this(items, items.Length) { }

    /// <summary>Popping candy</summary>
    public void Pop() => --Count;
}

/// <summary>SmallList module he-he</summary>
public static class SmallList
{
    internal const int ForLoopCopyCount = 4;
    internal const int DefaultInitialCapacity = 4;

    [MethodImpl((MethodImplOptions)256)]
    internal static void Expand<TItem>(ref TItem[] items)
    {
        // `| 1` is for the case when the length is 0
        var newItems = new TItem[(items.Length << 1) | 1]; // have fun to guess the new length, ha-ha ;-P
        if (items.Length > ForLoopCopyCount)
            Array.Copy(items, newItems, items.Length);
        else
            for (var i = 0; i < items.Length; ++i)
                newItems[i] = items[i];
        items = newItems;
    }

    /// <summary>Appends the new default item at the end of the items. Assumes that `index lte items.Length`! 
    /// `items` should be not null</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref TItem AddDefaultToNotNullItemsAndGetRef<TItem>(ref TItem[] items, int index)
    {
        Debug.Assert(index <= items.Length);
        if (index == items.Length)
            Expand(ref items);
        return ref items[index];
    }

    /// <summary>Appends the new default item at the end of the items. Assumes that `index lte items.Length`, `items` may be null</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref TItem AddDefaultAndGetRef<TItem>(ref TItem[] items, int index, int initialCapacity = DefaultInitialCapacity)
    {
        if (items == null)
        {
            Debug.Assert(index == 0);
            items = new TItem[initialCapacity];
            return ref items[index];
        }

        Debug.Assert(index <= items.Length);
        if (index == items.Length)
            Expand(ref items);
        return ref items[index];
    }

    /// <summary>Returns surely present item ref by its index</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref TItem GetSurePresentItemRef<TItem>(this ref SmallList<TItem> source, int index) =>
        ref source.Items[index];

    // todo: @perf add the not null variant
    /// <summary>Appends the new default item to the list and returns ref to it for write or read</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref TItem Add<TItem>(this ref SmallList<TItem> source, int initialCapacity = DefaultInitialCapacity) =>
        ref AddDefaultAndGetRef(ref source.Items, source.Count++, initialCapacity);

    /// <summary>Appends the new item to the list</summary>
    // todo: @perf add the not null variant
    [MethodImpl((MethodImplOptions)256)]
    public static void Add<TItem>(this ref SmallList<TItem> source, in TItem item, int initialCapacity = DefaultInitialCapacity) =>
        AddDefaultAndGetRef(ref source.Items, source.Count++, initialCapacity) = item;

    /// <summary>Looks for the item in the list and return its index if found or -1 for the absent item</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static int TryGetIndex<TItem, TEq>(this TItem[] items, in TItem it, int startIndex, int count, TEq eq = default, int notFoundResult = -1)
        where TEq : struct, IEq<TItem>
    {
        Debug.Assert(items != null);
        for (var i = startIndex; i < count; ++i)
        {
            ref var di = ref items[i]; // todo: @perf Marshall?
            if (eq.Equals(it, di))
                return i;
        }
        return notFoundResult;
    }

    /// <summary>Looks for the item in the list and return its index if found or -1 for the absent item</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static int TryGetIndex<TItem, TEq>(this ref SmallList<TItem> source, TItem it, TEq eq = default)
        where TEq : struct, IEq<TItem>
        => source.Items.TryGetIndex(it, 0, source.Count, eq);

    /// <summary>Returns the index of the found item or appends the item to the end of the list, and returns its index</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static int GetIndexOrAdd<TItem, TEq>(this ref SmallList<TItem> source, in TItem item, TEq eq = default)
        where TEq : struct, IEq<TItem>
    {
        var i = TryGetIndex(source.Items, in item, 0, source.Count, eq);
        if (i != -1)
            return i;
        i = source.Count;
        source.Add() = item;
        return i;
    }

    /// <summary>Returns surely present item ref by its index</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref TItem GetSurePresentItemRef<TItem>(this ref SmallList4<TItem> source, int index)
    {
        Debug.Assert(source.Count != 0);
        Debug.Assert(index < source.Count);
        switch (index)
        {
            case 0: return ref source._it0;
            case 1: return ref source._it1;
            case 2: return ref source._it2;
            case 3: return ref source._it3;
            default:
                Debug.Assert(source._rest != null, $"Expecting deeper items are already existing on stack at index: {index}");
                return ref source._rest[index - SmallList4<TItem>.StackCapacity];
        }
    }

    /// <summary>Returns a surely present item ref by its index</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref TItem GetSurePresentItemRef<TItem>(this ref Stack4<TItem> source, int index)
    {
        Debug.Assert(index < source.Capacity);
        switch (index)
        {
            case 0: return ref source._it0;
            case 1: return ref source._it1;
            case 2: return ref source._it2;
            case 3: return ref source._it3;
            default: return ref RefTools<TItem>.GetNullRef();
        }
    }

    /// <summary>Returns a surely present item ref by its index</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref T GetSurePresentItemRef<T, TStack>(this ref SmallList<T, TStack> list, int index)
        where TStack : struct, IStack<T, TStack>
    {
        Debug.Assert(list.Count != 0);
        Debug.Assert(index < list.Count);

        var stackCap = list.StackCapacity;
        if (index < stackCap)
            return ref list._stack.GetSurePresentRef(index);

        Debug.Assert(list._rest != null);
        return ref list._rest[index - stackCap];
    }

    /// <summary>Returns last present item ref, assumes that the list is not empty!</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref TItem GetLastSurePresentItem<TItem>(this ref SmallList4<TItem> source) =>
        ref source.GetSurePresentItemRef(source._count - 1);

    /// <summary>Appends the default item to the end of the list and returns the reference to it.</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref TItem AddDefaultAndGetRef<TItem>(this ref SmallList4<TItem> source)
    {
        var index = source._count++;
        switch (index)
        {
            case 0: return ref source._it0;
            case 1: return ref source._it1;
            case 2: return ref source._it2;
            case 3: return ref source._it3;
            default:
                return ref AddDefaultAndGetRef(ref source._rest, index - SmallList4<TItem>.StackCapacity);
        }
    }

    /// <summary>Looks for the item in the list and return its index if found or -1 for the absent item</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static int TryGetIndex<TItem, TEq>(this ref SmallList4<TItem> source, TItem it, TEq eq = default)
        where TEq : struct, IEq<TItem>
    {
        switch (source._count)
        {
            case 1:
                if (eq.Equals(it, source._it0)) return 0;
                break;

            case 2:
                if (eq.Equals(it, source._it0)) return 0;
                if (eq.Equals(it, source._it1)) return 1;
                break;

            case 3:
                if (eq.Equals(it, source._it0)) return 0;
                if (eq.Equals(it, source._it1)) return 1;
                if (eq.Equals(it, source._it2)) return 2;
                break;

            case var n:
                if (eq.Equals(it, source._it0)) return 0;
                if (eq.Equals(it, source._it1)) return 1;
                if (eq.Equals(it, source._it2)) return 2;
                if (eq.Equals(it, source._it3)) return 3;
                const int StackCapacity = SmallList4<TItem>.StackCapacity;
                if (n == StackCapacity)
                    break;

                return source._rest.TryGetIndex(in it, 0, source._count - StackCapacity, eq, -1 - StackCapacity) + StackCapacity;
        }
        return -1;
    }

    /// <summary>Returns the index of the found item or appends the item to the end of the list, and returns its index</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static int GetIndexOrAdd<TItem, TEq>(this ref SmallList4<TItem> source, in TItem item, TEq eq = default)
        where TEq : struct, IEq<TItem>
    {
        switch (source._count)
        {
            case 0:
                source._count = 1;
                source._it0 = item;
                return 0;

            case 1:
                if (eq.Equals(item, source._it0)) return 0;
                source._count = 2;
                source._it1 = item;
                return 1;

            case 2:
                if (eq.Equals(item, source._it0)) return 0;
                if (eq.Equals(item, source._it1)) return 1;
                source._count = 3;
                source._it2 = item;
                return 2;

            case 3:
                if (eq.Equals(item, source._it0)) return 0;
                if (eq.Equals(item, source._it1)) return 1;
                if (eq.Equals(item, source._it2)) return 2;
                source._count = 4;
                source._it3 = item;
                return 3;

            default:
                if (eq.Equals(item, source._it0)) return 0;
                if (eq.Equals(item, source._it1)) return 1;
                if (eq.Equals(item, source._it2)) return 2;
                if (eq.Equals(item, source._it3)) return 3;
                var restCount = source._count - SmallList4<TItem>.StackCapacity;
                if (restCount != 0)
                {
                    var i = source._rest.TryGetIndex(item, 0, restCount, eq);
                    if (i != -1)
                        return i + SmallList4<TItem>.StackCapacity;
                }
                AddDefaultAndGetRef(ref source._rest, restCount) = item;
                return source._count++;
        }
    }

    /// <summary>Enumerates all the items</summary>
    public static SmallList4Enumerable<TItem> Enumerate<TItem>(this ref SmallList4<TItem> list) => new SmallList4Enumerable<TItem>(list);

    /// <summary>Enumerable on stack, without allocations</summary>
    public struct SmallList4Enumerable<TItem> : IEnumerable<TItem>, IEnumerable
    {
        private readonly SmallList4<TItem> _list;
        /// <summary>Constructor</summary>
        public SmallList4Enumerable(SmallList4<TItem> list) => _list = list;
        /// <inheritdoc />
        public SmallList4Enumerator<TItem> GetEnumerator() => new SmallList4Enumerator<TItem>(_list);
        IEnumerator<TItem> IEnumerable<TItem>.GetEnumerator() => GetEnumerator();
        IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
    }

    /// <summary>Enumerator on stack, without allocations</summary>
    public struct SmallList4Enumerator<TItem> : IEnumerator<TItem>, IEnumerator
    {
        private readonly SmallList4<TItem> _list;
        private int _index;
        internal SmallList4Enumerator(SmallList4<TItem> list)
        {
            _list = list;
            _index = -1;
        }
        private TItem _current;
        /// <inheritdoc />
        public TItem Current => _current;
        object IEnumerator.Current => _current;
        /// <inheritdoc />
        public bool MoveNext()
        {
            var index = ++_index;
            var list = _list;
            if (index < _list.Count)
                switch (index)
                {
                    case 0: _current = list._it0; return true;
                    case 1: _current = list._it1; return true;
                    case 2: _current = list._it2; return true;
                    case 3: _current = list._it3; return true;
                    default:
                        _current = list._rest[index - SmallList4<TItem>.StackCapacity];
                        return true;
                }
            return false;
        }
        /// <inheritdoc />
        public void Reset() => _index = -1;
        /// <inheritdoc />
        public void Dispose() { }
    }

    /// <summary>Returns surely present item ref by its index</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref TItem GetSurePresentItemRef<TItem>(this ref SmallList2<TItem> source, int index)
    {
        Debug.Assert(source.Count != 0);
        Debug.Assert(index < source.Count);
        switch (index)
        {
            case 0: return ref source._it0;
            case 1: return ref source._it1;
            default:
                Debug.Assert(source._rest != null, $"Expecting deeper items are already existing on stack at index: {index}");
                return ref source._rest[index - SmallList2<TItem>.StackCapacity];
        }
    }

    /// <summary>Returns last present item ref, assumes that the list is not empty!</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref TItem GetLastSurePresentItem<TItem>(this ref SmallList2<TItem> source) =>
        ref source.GetSurePresentItemRef(source._count - 1);

    /// <summary>Appends the default item to the end of the list and returns the reference to it.</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref TItem AddDefaultAndGetRef<TItem>(this ref SmallList2<TItem> source)
    {
        var index = source._count++;
        switch (index)
        {
            case 0: return ref source._it0;
            case 1: return ref source._it1;
            default:
                return ref AddDefaultAndGetRef(ref source._rest, index - SmallList2<TItem>.StackCapacity);
        }
    }

    /// <summary>Looks for the item in the list and return its index if found or -1 for the absent item</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static int TryGetIndex<TItem, TEq>(this ref SmallList2<TItem> source, TItem it, TEq eq = default)
        where TEq : struct, IEq<TItem>
    {
        switch (source._count)
        {
            case 1:
                if (eq.Equals(it, source._it0)) return 0;
                break;

            case var n:
                if (eq.Equals(it, source._it0)) return 0;
                if (eq.Equals(it, source._it1)) return 1;
                const int StackCapacity = SmallList2<TItem>.StackCapacity;
                if (n == StackCapacity)
                    break;
                return source._rest.TryGetIndex(in it, 0, source._count - StackCapacity, eq, -1 - StackCapacity) + StackCapacity;
        }
        return -1;
    }

    /// <summary>Returns the index of the found item or appends the item to the end of the list, and returns its index</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static int GetIndexOrAdd<TItem, TEq>(this ref SmallList2<TItem> source, TItem item, TEq eq = default)
        where TEq : struct, IEq<TItem>
    {
        switch (source._count)
        {
            case 0:
                source._count = 1;
                source._it0 = item;
                return 0;

            case 1:
                if (eq.Equals(item, source._it0)) return 0;
                source._count = 2;
                source._it1 = item;
                return 1;

            default:
                if (eq.Equals(item, source._it0)) return 0;
                if (eq.Equals(item, source._it1)) return 1;

                var restCount = source._count - SmallList2<TItem>.StackCapacity;
                if (restCount != 0)
                {
                    var i = source._rest.TryGetIndex(in item, 0, restCount, eq);
                    if (i != -1)
                        return i + SmallList2<TItem>.StackCapacity;
                }
                AddDefaultAndGetRef(ref source._rest, restCount) = item;
                return source._count++;
        }
    }
}

#pragma warning disable CS9101 // UnscopedRef goes wrong on Ubuntu

// todo: @wip generalized Stack is the WIP and may be moved to ImTools repo
/// <summary>Abstracts over collection of the items on stack of the fixed Capacity,
/// to be used as a part of the hybrid data structures which grow from stack to heap</summary>
public interface IStack<T, TStack>
    where TStack : struct, IStack<T, TStack>
{
    /// <summary>Count of items holding</summary>
    int Capacity { get; }

    /// <summary>Indexer</summary>
    T this[int index] { get; set; }

    /// <summary>Set indexed item via value passed by-ref</summary>
    void Set(int index, in T item);

    /// <summary>Gets the ref to the struct T field/item by index. Does not not check the index boundaries - do it externally!</summary>
    [UnscopedRef]
    ref T GetSurePresentRef(int index);

    /// <summary>Creates a span from the struct items</summary>
    [UnscopedRef]
    Span<T> AsSpan();
}

#pragma warning restore CS0436

internal struct Stack2<T>
{
    public const int StackCapacity = 2;
    internal T _it0, _it1;

    [UnscopedRef]
    [MethodImpl((MethodImplOptions)256)]
    public ref T GetSurePresentRef(int index)
    {
        Debug.Assert(index < StackCapacity);
        switch (index)
        {
            case 0: return ref _it0;
            default: return ref _it1;
        }
    }
}

/// <summary>Implementation of `IStack` for 4 items on stack</summary>
[StructLayout(LayoutKind.Sequential, Pack = 1)]
public struct Stack4<T> : IStack<T, Stack4<T>>
{
    /// <summary>Count of items on stack</summary>
    public const int StackCapacity = 4;

    internal T _it0, _it1, _it2, _it3;

    /// <inheritdoc/>
    public int Capacity => StackCapacity;

    /// <inheritdoc/>
    [UnscopedRef]
    [MethodImpl((MethodImplOptions)256)]
    public ref T GetSurePresentRef(int index)
    {
        Debug.Assert(index < StackCapacity);
        switch (index)
        {
            case 0: return ref _it0;
            case 1: return ref _it1;
            case 2: return ref _it2;
            default: return ref _it3;
        }
    }

#if NETSTANDARD2_0_OR_GREATER || NET472
    private delegate Span<T> AsSpanDelegate(ref Stack4<T> stack, int capacity);

    private static AsSpanDelegate CompileAsSpanDelegate()
    {
        var dynamicMethod = new DynamicMethod(
            "__AsSpan_Stack4_",
            typeof(Span<T>),
            new[] { typeof(Stack4<T>).MakeByRefType(), typeof(int) },
            typeof(Stack4<T>).Module,
            true
        );

        var spanConstructor = typeof(Span<T>).GetConstructor(new[] { typeof(void*), typeof(int) });
        Debug.Assert(spanConstructor != null);

        // Set capcity to estimated size = 1 + 1 + 1 + 5 + 1 = 9 bytes + a small buffer
        var il = dynamicMethod.GetILGenerator(16);

        // IL to replicate: return new Span<T>(Unsafe.AsPointer(ref this), StackCapacity);
        il.Emit(OpCodes.Ldarg_0);         // Load 'ref this'
        il.Emit(OpCodes.Conv_U);          // Convert managed reference to native unsigned int (void*)
        il.Emit(OpCodes.Ldarg_1);         // Load length (StackCapacity) argument
        il.Emit(OpCodes.Newobj, spanConstructor);
        il.Emit(OpCodes.Ret);

        return (AsSpanDelegate)dynamicMethod.CreateDelegate(typeof(AsSpanDelegate));
    }

    private static readonly Lazy<AsSpanDelegate> _lazyCompiledAsSpanDelegate = new(CompileAsSpanDelegate);

    /// <inheritdoc/>
    [UnscopedRef]
    [MethodImpl((MethodImplOptions)256)]
    public Span<T> AsSpan() => _lazyCompiledAsSpanDelegate.Value(ref this, StackCapacity);
#else
    /// <inheritdoc/>
    [UnscopedRef]
    [MethodImpl((MethodImplOptions)256)]
    public Span<T> AsSpan() => MemoryMarshal.CreateSpan(ref Unsafe.As<Stack4<T>, T>(ref this), StackCapacity);
#endif

    /// <inheritdoc/>
    public T this[int index]
    {
        [MethodImpl((MethodImplOptions)256)]
        get
        {
            Debug.Assert(index < StackCapacity);
            return index switch
            {
                0 => _it0,
                1 => _it1,
                2 => _it2,
                3 => _it3,
                _ => default,
            };
        }
        [MethodImpl((MethodImplOptions)256)]
        set => Set(index, in value);
    }

    /// <summary>Sets the value by the index</summary>
    [MethodImpl((MethodImplOptions)256)]
    public void Set(int index, in T value)
    {
        Debug.Assert(index < StackCapacity);
        switch (index)
        {
            case 0: _it0 = value; break;
            case 1: _it1 = value; break;
            case 2: _it2 = value; break;
            case 3: _it3 = value; break;
            default: break;
        }
    }
}

// todo: @wip
/// <summary>Generic version of SmallList abstracted for how much items are on stack</summary>
public struct SmallList<TItem, TStack>
    where TStack : struct, IStack<TItem, TStack>
{
    internal int _count;
    // For this warning it is fine `_stack` is never assigned to, and will always have its default value
#pragma warning disable CS0649
    internal TStack _stack;
#pragma warning restore CS0649

    internal TItem[] _rest;

    /// <inheritdoc />
    public int StackCapacity
    {
        [MethodImpl((MethodImplOptions)256)]
        get => _stack.Capacity;
    }

    /// <summary>Gets the number of items in the list</summary>
    public int Count
    {
        [MethodImpl((MethodImplOptions)256)]
        get => _count;
    }

    /// <summary>Returns surely present item by its index</summary>
    public TItem this[int index]
    {
        [MethodImpl((MethodImplOptions)256)]
        get
        {
            Debug.Assert(_count != 0);
            Debug.Assert(index < _count);
            var stackCap = _stack.Capacity;
            if (index < stackCap)
                return _stack[index];

            Debug.Assert(_rest != null);
            return _rest[index - stackCap];
        }
    }

    /// <summary>Adds the item to the end of the list aka the Stack.Push</summary>
    [MethodImpl((MethodImplOptions)256)]
    public void Add(in TItem item)
    {
        var index = _count++;
        var stackCap = _stack.Capacity;
        if (index < stackCap)
            _stack.Set(index, in item);
        else
            SmallList.AddDefaultAndGetRef(ref _rest, index - stackCap) = item;
    }
}

/// <summary>List with the number of first items (4) stored inside its struct and the rest in the growable array.
/// Supports addition and removal (remove is without resize) only at the end of the list, aka Stack behavior</summary>
[DebuggerDisplay("{Count} of {_it0?.ToString()}, {_it1?.ToString()}, {_it2?.ToString()}, {_it3?.ToString()}, ...")]
public struct SmallList4<TItem>
{
    /// <summary>The number of entries stored inside the map itself without moving them to array on heap</summary>
    public const int StackCapacity = 4;

    internal int _count;
    internal TItem _it0, _it1, _it2, _it3;
    internal TItem[] _rest;

    /// <summary>Gets the number of items in the list</summary>
    public int Count
    {
        [MethodImpl((MethodImplOptions)256)]
        get => _count;
    }

    /// <summary>Populate with one item</summary>
    [MethodImpl((MethodImplOptions)256)]
    public void Init1(TItem it0)
    {
        _count = 1;
        _it0 = it0;
    }

    /// <summary>Populate with two items</summary>
    [MethodImpl((MethodImplOptions)256)]
    public void Init2(TItem it0, TItem it1)
    {
        _count = 2;
        _it0 = it0;
        _it1 = it1;
    }

    /// <summary>Populate with 3 items</summary>
    [MethodImpl((MethodImplOptions)256)]
    public void Init3(TItem it0, TItem it1, TItem it2)
    {
        _count = 3;
        _it0 = it0;
        _it1 = it1;
        _it2 = it2;
    }

    /// <summary>Populate with 4 items</summary>
    [MethodImpl((MethodImplOptions)256)]
    public void Init4(TItem it0, TItem it1, TItem it2, TItem it3)
    {
        _count = StackCapacity;
        _it0 = it0;
        _it1 = it1;
        _it2 = it2;
        _it3 = it3;
    }

    /// <summary>Populate with `count` items</summary>
    [MethodImpl((MethodImplOptions)256)]
    public void Init(int count, in TItem it0, in TItem it1, in TItem it2, in TItem it3)
    {
        Debug.Assert(count >= 0 & count <= 4);
        _count = count;
        _it0 = it0;
        _it1 = it1;
        _it2 = it2;
        _it3 = it3;
    }

    /// <summary>Populates the list stack items and owns/uses the provided rest array and its count</summary>
    [MethodImpl((MethodImplOptions)256)]
    public void Embed(TItem it0, TItem it1, TItem it2, TItem it3, TItem[] rest, int restCount)
    {
        _it0 = it0;
        _it1 = it1;
        _it2 = it2;
        _it3 = it3;
        _rest = rest;
        _count = StackCapacity + restCount;
    }

    /// <summary>Populate with arbitrary items</summary>
    public void InitFromList<TList>(TList items) where TList : IReadOnlyList<TItem>
    {
        switch (items.Count)
        {
            case 0:
                break;
            case 1:
                Init1(items[0]);
                break;
            case 2:
                Init2(items[0], items[1]);
                break;
            case 3:
                Init3(items[0], items[1], items[2]);
                break;
            case 4:
                Init4(items[0], items[1], items[2], items[3]);
                break;
            default:
                Init4(items[0], items[1], items[2], items[3]);

                // keep the capacity at count + StackCapacity
                _count = items.Count;
                var rest = new TItem[_count]; // todo: @perf take from the ArrayPool.Shared
                for (var i = StackCapacity; i < _count; ++i)
                    rest[i - StackCapacity] = items[i]; // todo: @perf does List have a Copy?
                _rest = rest;
                break;
        }
    }

    /// <summary>Returns surely present item by its index</summary>
    public TItem this[int index]
    {
        [MethodImpl((MethodImplOptions)256)]
        get
        {
            Debug.Assert(_count != 0);
            Debug.Assert(index < _count);
            switch (index)
            {
                case 0: return _it0;
                case 1: return _it1;
                case 2: return _it2;
                case 3: return _it3;
                default:
                    Debug.Assert(_rest != null, $"Expecting deeper items are already existing on stack at index: {index}");
                    return _rest[index - StackCapacity];
            }
        }
    }

    /// <summary>Adds the item to the end of the list aka the Stack.Push</summary>
    [MethodImpl((MethodImplOptions)256)]
    public void Add(in TItem item)
    {
        var index = _count++;
        switch (index)
        {
            case 0: _it0 = item; break;
            case 1: _it1 = item; break;
            case 2: _it2 = item; break;
            case 3: _it3 = item; break;
            default:
                SmallList.AddDefaultAndGetRef(ref _rest, index - StackCapacity) = item;
                break;
        }
    }

    /// <summary>Adds the default item to the end of the list aka the Stack.Push default</summary>
    [MethodImpl((MethodImplOptions)256)]
    public void AddDefault()
    {
        if (++_count >= StackCapacity)
            SmallList.AddDefaultAndGetRef(ref _rest, _count - StackCapacity);
    }

    /// <summary>Removes the last item from the list aka the Stack Pop. Assumes that the list is not empty!</summary>
    [MethodImpl((MethodImplOptions)256)]
    public void RemoveLastSurePresentItem()
    {
        Debug.Assert(_count != 0);
        var index = --_count;
        switch (index)
        {
            case 0: _it0 = default; break;
            case 1: _it1 = default; break;
            case 2: _it2 = default; break;
            case 3: _it3 = default; break;
            default:
                Debug.Assert(_rest != null, $"Expecting a deeper parent stack created before accessing it here at level {index}");
                _rest[index - StackCapacity] = default;
                break;
        }
    }

    /// <summary>Adds another list to the current list</summary>
    public void AddList(in SmallList4<TItem> added)
    {
        if (_count == 0)
        {
            Init4(added._it0, added._it1, added._it2, added._it3);
            var addedRestCount = added.Count - StackCapacity;
            if (addedRestCount > 0)
            {
                _rest = new TItem[addedRestCount + StackCapacity]; // add a bit of the empty room of `StackCapacity` at the end, so you may add the new items without immediate resize 
                Array.Copy(added._rest, 0, _rest, 0, addedRestCount);
            }
            // Setting the _count here because Init4 above sets the count to 4, but in reality the added list may have less items than 4
            _count = added.Count;
            return;
        }
        switch (added.Count)
        {
            case 0: break;
            case 1: Add(added._it0); break;
            case 2: Add(added._it0); Add(added._it1); break;
            case 3: Add(added._it0); Add(added._it1); Add(added._it2); break;
            case 4: Add(added._it0); Add(added._it1); Add(added._it2); Add(added._it3); break;
            case var addedCount:
                Add(added._it0); Add(added._it1); Add(added._it2); Add(added._it3);

                // Here the _count reflects the 4 added items above
                var addedRestCount = addedCount - StackCapacity;
                var currRestCount = _count - StackCapacity;

                // Expand the rest so it can hold the current items and added items
                if (_rest.Length < currRestCount + addedRestCount)
                {
                    var newRest = new TItem[currRestCount + addedRestCount + StackCapacity]; // add a bit of the empty room of `StackCapacity` at the end
                    Array.Copy(_rest, 0, newRest, 0, currRestCount);
                    _rest = newRest;
                }

                // Copy the added items to the rest
                Array.Copy(added._rest, 0, _rest, currRestCount, addedRestCount);
                _count += addedRestCount;
                break;
        }
    }

    /// <summary>Drops the first item out of the list, and shifts the remaining items indices by -1, so the second item become the first and so on.
    /// If the list is empty the method does nothing.
    /// The method returns number of the dropped items, e.g. 0 or 1.
    /// The method is similar to JS Array.shift</summary>
    [MethodImpl((MethodImplOptions)256)]
    public int DropFirst()
    {
        switch (_count)
        {
            case 0: return 0;
            case 1: _it0 = default; break;
            case 2: _it0 = _it1; _it1 = default; break;
            case 3: _it0 = _it1; _it1 = _it2; _it2 = default; break;
            case 4: _it0 = _it1; _it1 = _it2; _it2 = _it3; _it3 = default; break;
            default:
                _it0 = _it1; _it1 = _it2; _it2 = _it3; _it3 = _rest[0];
                Array.Copy(_rest, 1, _rest, 0, (_count - StackCapacity) - 1);
                _rest[(_count - StackCapacity) - 1] = default;
                break;
        }
        --_count;
        return 1;
    }

    ///<summary>Clears the list, but keeps the already allocated array on heap to reuse in the future</summary>
    public void Clear()
    {
        _it0 = default;
        _it1 = default;
        _it2 = default;
        _it3 = default;
        if (_count > StackCapacity)
        {
            Debug.Assert(_rest != null);
            Array.Clear(_rest, 0, _rest.Length);
        }
        _count = 0;
    }

    /// <summary>Drops the first `n` items out of the list, and shifts the remaining items indices by -1, so the second item become the first and so on.
    /// If the list is empty the method does nothing.
    /// The method returns number of the dropped items, e.g. 0 or 1.
    /// The method is similar to JS Array.shift</summary>
    public int DropFirstN(int n)
    {
        if (n <= 0)
            return 0;

        if (n >= _count)
        {
            Clear();
            return _count;
        }

        if (_count <= StackCapacity)
        {
            switch (n)
            {
                case 1: _it0 = _it1; _it1 = _it2; _it2 = _it3; _it3 = default; break;
                case 2: _it0 = _it2; _it1 = _it3; _it2 = default; _it3 = default; break;
                // no need to check for n == 4, as the n is strictly less than _count in the check above
                default: _it0 = _it3; _it1 = default; _it2 = default; _it3 = default; break;
            }
        }
        else
        {
            Debug.Assert(_rest != null);
            var last = (_count - StackCapacity) - n;
            switch (n)
            {
                case 1:
                    _it0 = _it1; _it1 = _it2; _it2 = _it3; _it3 = _rest[0];
                    Array.Copy(_rest, 1, _rest, 0, last); // don't worry if the `last` is 0 (for the 5 item list), Array.Copy will handle 0 just fine.
                    _rest[last] = default;
                    break;
                case 2:
                    _it0 = _it2; _it1 = _it3; _it2 = _rest[0]; _it3 = _rest[1];
                    Array.Copy(_rest, 2, _rest, 0, last);
                    _rest[last] = default; _rest[last + 1] = default;
                    break;
                case 3:
                    _it0 = _it3; _it1 = _rest[0]; _it2 = _rest[1]; _it3 = _rest[2];
                    Array.Copy(_rest, 3, _rest, 0, last);
                    _rest[last] = default; _rest[last + 1] = default; _rest[last + 2] = default;
                    break;
                default:
                    _it0 = _rest[0]; _it1 = _rest[1]; _it2 = _rest[2]; _it3 = _rest[3];
                    Array.Copy(_rest, n, _rest, 0, last);
                    Array.Clear(_rest, last, n);
                    break;
            }
        }

        _count -= n;
        return n;
    }

    /// <summary>Copy items to new the array</summary>
    public TItem[] ToArray()
    {
        switch (_count)
        {
            case 0: return Tools.Empty<TItem>();
            case 1: return new[] { _it0 };
            case 2: return new[] { _it0, _it1 };
            case 3: return new[] { _it0, _it1, _it2 };
            case 4: return new[] { _it0, _it1, _it2, _it3 };
            default:
                var items = new TItem[_count];
                items[0] = _it0;
                items[1] = _it1;
                items[2] = _it2;
                items[3] = _it3;
                Array.Copy(_rest, 0, items, 4, _count - StackCapacity);
                return items;
        }
    }
}

/// <summary>List with the number of first items (2) stored inside its struct and the rest in the growable array.
/// Supports addition and removal (remove is without resize) only at the end of the list, aka Stack behavior</summary>
[DebuggerDisplay("{Count} of {_it0?.ToString()}, {_it1?.ToString()}, ...")]
public struct SmallList2<TItem>
{
    /// <summary>The number of entries stored inside the map itself without moving them to array on heap</summary>
    public const int StackCapacity = 2;

    internal int _count;
    internal TItem _it0, _it1;
    internal TItem[] _rest;

    /// <summary>Good stuff</summary>
    [MethodImpl((MethodImplOptions)256)]
    public void InitCount(int count)
    {
        _count = count;
        if (count > StackCapacity)
            _rest = new TItem[count]; // add the StackCapacity empty space at the end, we may use it later for BuildToArray
    }

    /// <summary>Populate with one item</summary>
    [MethodImpl((MethodImplOptions)256)]
    public void Populate1(TItem it0)
    {
        _count = 1;
        _it0 = it0;
    }

    /// <summary>Populate with two items</summary>
    [MethodImpl((MethodImplOptions)256)]
    public void Populate2(TItem it0, TItem it1)
    {
        _count = StackCapacity;
        _it0 = it0;
        _it1 = it1;
    }

    /// <summary>Populate with more than two items</summary>
    [MethodImpl((MethodImplOptions)256)]
    public void Populate(TItem it0, TItem it1, params TItem[] rest)
    {
        _count = StackCapacity + rest.Length;
        _it0 = it0;
        _it1 = it1;
        _rest = rest;
    }

    /// <summary>Populate with arbitrary items</summary>
    public void Populate<TList>(TList items) where TList : IReadOnlyList<TItem>
    {
        switch (items.Count)
        {
            case 0:
                break;
            case 1:
                Populate1(items[0]);
                break;
            case 2:
                Populate2(items[0], items[1]);
                break;
            default:
                Populate2(items[0], items[1]);

                // keep the capacity at count + StackCapacity
                _count = items.Count;
                var rest = new TItem[_count]; // todo: @perf take from the ArrayPool.Shared
                for (var i = StackCapacity; i < _count; ++i)
                    rest[i - StackCapacity] = items[i]; // todo: @perf does List have a Copy?
                _rest = rest;
                break;
        }
    }

    /// <summary>Gets the number of items in the list</summary>
    public int Count
    {
        [MethodImpl((MethodImplOptions)256)]
        get => _count;
    }

    /// <summary>Returns surely present item by its index</summary>
    public TItem this[int index]
    {
        [MethodImpl((MethodImplOptions)256)]
        get
        {
            Debug.Assert(_count != 0);
            Debug.Assert(index < _count);
            switch (index)
            {
                case 0: return _it0;
                case 1: return _it1;
                default:
                    Debug.Assert(_rest != null, $"Expecting deeper items are already existing on stack at index: {index}");
                    return _rest[index - StackCapacity];
            }
        }
    }

    /// <summary>Adds the item to the end of the list aka the Stack.Push</summary>
    [MethodImpl((MethodImplOptions)256)]
    public void Add(in TItem item)
    {
        var index = _count++;
        switch (index)
        {
            case 0: _it0 = item; break;
            case 1: _it1 = item; break;
            default:
                SmallList.AddDefaultAndGetRef(ref _rest, index - StackCapacity) = item;
                break;
        }
    }

    /// <summary>Adds the default item to the end of the list aka the Stack.Push default</summary>
    [MethodImpl((MethodImplOptions)256)]
    public void AddDefault()
    {
        if (++_count >= StackCapacity)
            SmallList.AddDefaultAndGetRef(ref _rest, _count - StackCapacity);
    }

    /// <summary>Removes the last item from the list aka the Stack Pop. Assumes that the list is not empty!</summary>
    [MethodImpl((MethodImplOptions)256)]
    public void RemoveLastSurePresentItem()
    {
        Debug.Assert(_count != 0);
        var index = --_count;
        switch (index)
        {
            case 0: _it0 = default; break;
            case 1: _it1 = default; break;
            default:
                Debug.Assert(_rest != null, $"Expecting a deeper parent stack created before accessing it here at level {index}");
                _rest[index - StackCapacity] = default;
                break;
        }
    }

    /// <summary>Copy items to new the array</summary>
    [MethodImpl((MethodImplOptions)256)]
    public TItem[] ToArray()
    {
        switch (_count)
        {
            case 0: return Tools.Empty<TItem>();
            case 1: return new[] { _it0 };
            case 2: return new[] { _it0, _it1 };
            default:
                var items = new TItem[_count];
                items[0] = _it0;
                items[1] = _it1;
                Array.Copy(_rest, 0, items, 2, _count - StackCapacity);
                return items;
        }
    }
}

/// <summary>Printable thing via provided printer </summary>
public interface IPrintable
{
    /// <summary>Print to the provided string builder via the provided printer.</summary>
    StringBuilder Print(StringBuilder s, Func<StringBuilder, object, StringBuilder> printer);
}

/// <summary>Produces good enough hash codes for the fields</summary>
public static class Hasher
{
    /// <summary>Combines hashes of two fields</summary>
    public static int Combine<T1, T2>(T1 a, T2 b)
    {
        var bh = b?.GetHashCode() ?? 0;
        if (ReferenceEquals(a, null))
            return bh;
        var ah = a.GetHashCode();
        if (ah == 0)
            return bh;
        return Combine(ah, bh);
    }

    /// <summary>Inspired by System.Tuple.CombineHashCodes</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static int Combine(int h1, int h2)
    {
        unchecked
        {
            return (h1 << 5) + h1 ^ h2;
        }
    }
}

/// <summary>Configures removed key tombstone, equality and hash function for the SmallMap and friends</summary>
public interface IEq<K> : IEqualityComparer<K>
{
    /// <summary>Defines the value of the key indicating the removed entry</summary>
    K GetTombstone();
}

/// <summary>Default comparer using the `object.GetHashCode` and `object.Equals` overloads</summary>
public struct DefaultEq<K> : IEq<K>
{
    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public K GetTombstone() => default;

    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public bool Equals(K x, K y) => ReferenceEquals(x, y) || x.Equals(y);

    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public int GetHashCode(K key) => key.GetHashCode();
}

/// <summary>Uses the integer itself as hash code and `==` for equality</summary>
public struct IntEq : IEq<int>
{
    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public int GetTombstone() => int.MinValue; // todo: @improve separate the tombstone from the hash

    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public bool Equals(int x, int y) => x == y;

    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public int GetHashCode(int key) => key;
}

/// <summary>Instances of the RefEq for the often used K</summary>
public static class RefEq
{
    /// <summary>RefEq for object, possibly the only thing you need</summary>
    public static readonly RefEq<object> OfObject = default;
}

// todo: @wip should we even need K here, maybe object implementation is enough?
/// <summary>Uses the `object.GetHashCode` and `object.ReferenceEquals`</summary>
public struct RefEq<K> : IEq<K> where K : class
{
    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public K GetTombstone() => null;

    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public bool Equals(K x, K y) => ReferenceEquals(x, y);

    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public int GetHashCode(K key) => RuntimeHelpers.GetHashCode(key);
}

/// <summary>Compares via `ReferenceEquals` and gets the hash faster via `RuntimeHelpers.GetHashCode`</summary>
public struct RefEq<A, B> : IEq<(A, B)>
    where A : class
    where B : class
{
    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public (A, B) GetTombstone() => (null, null);

    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public bool Equals((A, B) x, (A, B) y) =>
        ReferenceEquals(x.Item1, y.Item1) && ReferenceEquals(x.Item2, y.Item2);

    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public int GetHashCode((A, B) key) =>
        Hasher.Combine(RuntimeHelpers.GetHashCode(key.Item1), RuntimeHelpers.GetHashCode(key.Item2));
}

/// <summary>Compares via `ReferenceEquals` and gets the hash faster via `RuntimeHelpers.GetHashCode`</summary>
public struct RefEq<A, B, C> : IEq<(A, B, C)>
    where A : class
    where B : class
    where C : class
{
    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public (A, B, C) GetTombstone() => (null, null, null);

    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public bool Equals((A, B, C) x, (A, B, C) y) =>
        ReferenceEquals(x.Item1, y.Item1) && ReferenceEquals(x.Item2, y.Item2) && ReferenceEquals(x.Item3, y.Item3);

    /// <inheritdoc />
    [MethodImpl((MethodImplOptions)256)]
    public int GetHashCode((A, B, C) key) =>
        Hasher.Combine(RuntimeHelpers.GetHashCode(key.Item1), Hasher.Combine(RuntimeHelpers.GetHashCode(key.Item2), RuntimeHelpers.GetHashCode(key.Item3)));
}


/// <summary>Configuration and the tools for the SmallMap and friends</summary>
public static class SmallMap4
{
    internal const byte MinFreeCapacityShift = 3; // e.g. for the capacity 16: 16 >> 3 => 2, 12.5% of the free hash slots (it does not mean the entries free slot)
    internal const byte MinHashesCapacityBitShift = 4; // 1 << 4 == 16

    /// <summary>Upper hash bits spent on storing the probes, e.g. 5 bits mean 31 probes max.</summary>
    public const byte MaxProbeBits = 5;
    internal const byte MaxProbeCount = (1 << MaxProbeBits) - 1;
    internal const byte ProbeCountShift = 32 - MaxProbeBits;
    internal const int HashAndIndexMask = ~(MaxProbeCount << ProbeCountShift);

    /// <summary>The number of entries stored inside the map itself without moving them to array on heap</summary>
    public const int StackEntriesCount = 4;

    /// <summary>Creates the map with the <see cref="SingleArrayEntries{K, V, TEq}"/> storage</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static SmallMap4<K, V, TEq, SingleArrayEntries<K, V, TEq>> New<K, V, TEq>(byte capacityBitShift = 0)
        where TEq : struct, IEq<K> => new(capacityBitShift);

    /// <summary>Holds a single entry consisting of key and value. 
    /// Value may be set or changed but the key is set in stone (by construction).</summary>
    [DebuggerDisplay("{Key?.ToString()}->{Value}")]
    public struct Entry<K, V>
    {
        /// <summary>The readonly key</summary>
        public K Key;
        /// <summary>The mutable value</summary>
        public V Value;
        /// <summary>Construct with the key and default value</summary>
        public Entry(K key) => Key = key;
        /// <summary>Construct with the key and value</summary>
        public Entry(K key, V value)
        {
            Key = key;
            Value = value;
        }
    }

    /// binary representation of the `int`
    public static string ToB(int x) => System.Convert.ToString(x, 2).PadLeft(32, '0');

    [MethodImpl((MethodImplOptions)256)]
#if NET7_0_OR_GREATER
    internal static ref int GetHashRef(ref int start, int distance) => ref Unsafe.Add(ref start, distance);
#else
    internal static ref int GetHashRef(ref int[] start, int distance) => ref start[distance];
#endif

    [MethodImpl((MethodImplOptions)256)]
#if NET7_0_OR_GREATER
    internal static int GetHash(ref int start, int distance) => Unsafe.Add(ref start, distance);
#else
    internal static int GetHash(ref int[] start, int distance) => start[distance];
#endif

    // todo: @improve can we move the Entry into the type parameter to configure and possibly save the memory e.g. for the sets? 
    /// <summary>Abstraction to configure your own entries data structure. Check the derived types for the examples</summary>
    public interface IEntries<K, V, TEq> where TEq : IEq<K>
    {
        /// <summary>Initializes the entries storage to the specified capacity via the number of <paramref name="capacityBitShift"/> bits in the capacity</summary>
        void Init(byte capacityBitShift);

        /// <summary>Returns the reference to entry by its index, index should map to the present/non-removed entry</summary>
        ref Entry<K, V> GetSurePresentEntryRef(int index);

        /// <summary>Adds the key at the "end" of entries - so the order of addition is preserved.</summary>
        ref V AddKeyAndGetValueRef(K key, int index);
    }

    internal const int MinEntriesCapacity = 2;

    /// <summary>For now to use in the Set as a value</summary>
    public readonly struct NoValue { }

    /// <summary>Stores the entries in a single dynamically reallocated growing array</summary>
    [DebuggerDisplay("{Capacity:_entries?.Length ?? 0} of {_entries?[0]}, {_entries?[1]}, ...")]
    public struct SingleArrayEntries<K, V, TEq> : IEntries<K, V, TEq> where TEq : struct, IEq<K>
    {
        internal Entry<K, V>[] _entries;

        /// <inheritdoc/>
        public void Init(byte capacityBitShift) =>
            _entries = new Entry<K, V>[1 << capacityBitShift];

        /// <inheritdoc/>
        [MethodImpl((MethodImplOptions)256)]
        public ref Entry<K, V> GetSurePresentEntryRef(int index)
        {
#if NET7_0_OR_GREATER
            return ref Unsafe.Add(ref MemoryMarshal.GetArrayDataReference(_entries), index);
#else
            return ref _entries[index];
#endif
        }

        /// <inheritdoc/>
        [MethodImpl((MethodImplOptions)256)]
        public ref V AddKeyAndGetValueRef(K key, int index)
        {
            if (index == _entries.Length)
                Array.Resize(ref _entries, index << 1);
#if NET7_0_OR_GREATER
            ref var e = ref Unsafe.Add(ref MemoryMarshal.GetArrayDataReference(_entries), index);
#else
            ref var e = ref _entries[index];
#endif
            e.Key = key;
            return ref e.Value;
        }
    }

    /// <summary>Finds the stored value by key.
    /// UNSAFE: don't try to set the returned value if the `found == false`, because you will be setting the shared static value.
    /// You may set the value ONLY if `found == true`,
    /// If you want this kind of sematic use `AddOrGetValueRef`</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref V TryGetValueRefUnsafe<K, V, TEq, TEntries>(this ref SmallMap4<K, V, TEq, TEntries> map, K key, out bool found)
        where TEq : struct, IEq<K>
        where TEntries : struct, IEntries<K, V, TEq>
    {
        if (map._count > StackEntriesCount)
            return ref map.TryGetValueRefByHash(key, out found);
        switch (map._count)
        {
            case 1:
                if (found = default(TEq).Equals(key, map._e0.Key)) return ref map._e0.Value;
                break;
            case 2:
                if (found = default(TEq).Equals(key, map._e0.Key)) return ref map._e0.Value;
                if (found = default(TEq).Equals(key, map._e1.Key)) return ref map._e1.Value;
                break;
            case 3:
                if (found = default(TEq).Equals(key, map._e0.Key)) return ref map._e0.Value;
                if (found = default(TEq).Equals(key, map._e1.Key)) return ref map._e1.Value;
                if (found = default(TEq).Equals(key, map._e2.Key)) return ref map._e2.Value;
                break;
            case 4:
                if (found = default(TEq).Equals(key, map._e0.Key)) return ref map._e0.Value;
                if (found = default(TEq).Equals(key, map._e1.Key)) return ref map._e1.Value;
                if (found = default(TEq).Equals(key, map._e2.Key)) return ref map._e2.Value;
                if (found = default(TEq).Equals(key, map._e3.Key)) return ref map._e3.Value;
                break;
        }
        found = false;
        return ref RefTools<V>.GetNullRef();
    }

    /// <summary>Finds the stored value by key. If found returns ref to the value it can be modified in place.</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static bool ContainsKey<K, V, TEq, TEntries>(this ref SmallMap4<K, V, TEq, TEntries> map, K key)
        where TEq : struct, IEq<K>
        where TEntries : struct, IEntries<K, V, TEq>
    {
        if (map._count > StackEntriesCount)
        {
            _ = map.TryGetValueRefByHash(key, out var found);
            return found;
        }

        // for small counts just compare the keys without calculating the hashes
        var eq = default(TEq);
        return map._count switch
        {
            1 => eq.Equals(key, map._e0.Key),
            2 => eq.Equals(key, map._e0.Key) || eq.Equals(key, map._e1.Key),
            3 => eq.Equals(key, map._e0.Key) || eq.Equals(key, map._e1.Key) || eq.Equals(key, map._e2.Key),
            4 => eq.Equals(key, map._e0.Key) || eq.Equals(key, map._e1.Key) || eq.Equals(key, map._e2.Key) || eq.Equals(key, map._e3.Key),
            _ => false,
        };
    }

    /// <summary>Gets the reference to the existing value by the provided key (found == true),
    /// or adds a new key-value pair (found == false) and allows to set the returned value.</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref V AddOrGetValueRef<K, V, TEq, TEntries>(this ref SmallMap4<K, V, TEq, TEntries> map, K key, out bool found)
        where TEq : struct, IEq<K>
        where TEntries : struct, IEntries<K, V, TEq>
    {
        if (map._count > StackEntriesCount)
            return ref map.AddOrGetValueRefByHash(key, out found);
        found = true;
        switch (map._count)
        {
            case 0:
                found = false;
                map._count = 1;
                map._e0.Key = key;
                return ref map._e0.Value;

            case 1:
                if (default(TEq).Equals(key, map._e0.Key)) return ref map._e0.Value;
                found = false;
                map._count = 2;
                map._e1.Key = key;
                return ref map._e1.Value;

            case 2:
                if (default(TEq).Equals(key, map._e0.Key)) return ref map._e0.Value;
                if (default(TEq).Equals(key, map._e1.Key)) return ref map._e1.Value;
                found = false;
                map._count = 3;
                map._e2.Key = key;
                return ref map._e2.Value;

            case 3:
                if (default(TEq).Equals(key, map._e0.Key)) return ref map._e0.Value;
                if (default(TEq).Equals(key, map._e1.Key)) return ref map._e1.Value;
                if (default(TEq).Equals(key, map._e2.Key)) return ref map._e2.Value;
                found = false;
                map._count = 4;
                map._e3.Key = key;
                return ref map._e3.Value;

            default:
                if (default(TEq).Equals(key, map._e0.Key)) return ref map._e0.Value;
                if (default(TEq).Equals(key, map._e1.Key)) return ref map._e1.Value;
                if (default(TEq).Equals(key, map._e2.Key)) return ref map._e2.Value;
                if (default(TEq).Equals(key, map._e3.Key)) return ref map._e3.Value;
                found = false;

                map._capacityBitShift = MinHashesCapacityBitShift;
                map._packedHashesAndIndexes = new int[1 << MinHashesCapacityBitShift];

                var indexMask = (1 << MinHashesCapacityBitShift) - 1;

                // todo: @perf optimize by calculating the keys hashes and putting them into the span and iterating over them inside a single method

                map.AddInitialHashWithoutResizing(map._e0.Key, 0, indexMask);
                map.AddInitialHashWithoutResizing(map._e1.Key, 1, indexMask);
                map.AddInitialHashWithoutResizing(map._e2.Key, 2, indexMask);
                map.AddInitialHashWithoutResizing(map._e3.Key, 3, indexMask);
                map.AddInitialHashWithoutResizing(key, StackEntriesCount, indexMask);

                map._count = 5;
                map._entries.Init(2);

                // we do not copying the entries because we provide the stable value reference guaranties
                return ref map._entries.AddKeyAndGetValueRef(key, 0);
        }
    }

    private static void AddInitialHashWithoutResizing<K, V, TEq, TEntries>(this ref SmallMap4<K, V, TEq, TEntries> map, K key, int index, int indexMask)
        where TEq : struct, IEq<K>
        where TEntries : struct, IEntries<K, V, TEq>
    {
#if NET7_0_OR_GREATER
        ref var hashesAndIndexes = ref MemoryMarshal.GetArrayDataReference(map._packedHashesAndIndexes);
#else
        var hashesAndIndexes = map._packedHashesAndIndexes;
#endif
        var hash = default(TEq).GetHashCode(key);
        var hashIndex = hash & indexMask;

        // 1. Skip over hashes with the bigger and equal probes. The hashes with bigger probes overlapping from the earlier ideal positions
        ref var h = ref GetHashRef(ref hashesAndIndexes, hashIndex);
        var probes = 1;
        while ((h >>> ProbeCountShift) >= probes)
        {
            h = ref GetHashRef(ref hashesAndIndexes, ++hashIndex & indexMask);
            ++probes;
        }

        // 3. We did not find the hash and therefore the key, so insert the new entry
        var hRobinHooded = h;
        h = (probes << ProbeCountShift) | (hash & HashAndIndexMask & ~indexMask) | index;

        // 4. If the robin hooded hash is empty then we stop
        // 5. Otherwise we steal the slot with the smaller probes
        probes = hRobinHooded >>> ProbeCountShift;
        while (hRobinHooded != 0)
        {
            h = ref GetHashRef(ref hashesAndIndexes, ++hashIndex & indexMask);
            if ((h >>> ProbeCountShift) < ++probes)
            {
                var tmp = h;
                h = (probes << ProbeCountShift) | (hRobinHooded & HashAndIndexMask);
                hRobinHooded = tmp;
                probes = hRobinHooded >>> ProbeCountShift;
            }
        }
    }

    /// <summary>Adds the sure absent key entry. 
    /// Provides the performance in scenarios where you look for present key, and using it, and if ABSENT then add the new one.
    /// So this method optimized NOT to look for the present item for the second time in SEQUENCE</summary>
    public static ref V AddSureAbsentDefaultAndGetRef<K, V, TEq, TEntries>(this ref SmallMap4<K, V, TEq, TEntries> map, K key)
        where TEq : struct, IEq<K>
        where TEntries : struct, IEntries<K, V, TEq>
    {
        if (map._count > StackEntriesCount)
            return ref map.AddSureAbsentDefaultAndGetRefByHash(key);
        switch (map._count)
        {
            case 0:
                map._count = 1;
                map._e0.Key = key;
                return ref map._e0.Value;

            case 1:
                map._count = 2;
                map._e1.Key = key;
                return ref map._e1.Value;

            case 2:
                map._count = 3;
                map._e2.Key = key;
                return ref map._e2.Value;

            case 3:
                map._count = 4;
                map._e3.Key = key;
                return ref map._e3.Value;

            default:
                map._capacityBitShift = MinHashesCapacityBitShift;
                map._packedHashesAndIndexes = new int[1 << MinHashesCapacityBitShift];

                var indexMask = (1 << MinHashesCapacityBitShift) - 1;

                map.AddInitialHashWithoutResizing(map._e0.Key, 0, indexMask);
                map.AddInitialHashWithoutResizing(map._e1.Key, 1, indexMask);
                map.AddInitialHashWithoutResizing(map._e2.Key, 2, indexMask);
                map.AddInitialHashWithoutResizing(map._e3.Key, 3, indexMask);
                map.AddInitialHashWithoutResizing(key, StackEntriesCount, indexMask);

                map._count = 5;
                map._entries.Init(2);
                return ref map._entries.AddKeyAndGetValueRef(key, 0);
        }
    }

    [MethodImpl((MethodImplOptions)256)]
    private static ref V AddSureAbsentDefaultAndGetRefByHash<K, V, TEq, TEntries>(this ref SmallMap4<K, V, TEq, TEntries> map, K key)
        where TEq : struct, IEq<K>
        where TEntries : struct, IEntries<K, V, TEq>
    {
        // if the free space is less than 1/8 of capacity (12.5%) then Resize
        var indexMask = (1 << map._capacityBitShift) - 1;
        if (indexMask - map._count <= (indexMask >>> MinFreeCapacityShift))
            indexMask = map.ResizeHashes(indexMask);

        var hash = default(TEq).GetHashCode(key);
        var hashIndex = hash & indexMask;

#if NET7_0_OR_GREATER
        ref var hashesAndIndexes = ref MemoryMarshal.GetArrayDataReference(map._packedHashesAndIndexes);
#else
        var hashesAndIndexes = map._packedHashesAndIndexes;
#endif
        ref var h = ref GetHashRef(ref hashesAndIndexes, hashIndex);

        // 1. Skip over hashes with the bigger and equal probes. The hashes with bigger probes overlapping from the earlier ideal positions
        var probes = 1;
        while ((h >>> ProbeCountShift) >= probes)
        {
            h = ref GetHashRef(ref hashesAndIndexes, ++hashIndex & indexMask);
            ++probes;
        }

        // 3. We did not find the hash and therefore the key, so insert the new entry
        var hRobinHooded = h;
        h = (probes << ProbeCountShift) | (hash & HashAndIndexMask & ~indexMask) | map._count;

        // 4. If the robin hooded hash is empty then we stop
        // 5. Otherwise we steal the slot with the smaller probes
        probes = hRobinHooded >>> ProbeCountShift;
        while (hRobinHooded != 0)
        {
            h = ref GetHashRef(ref hashesAndIndexes, ++hashIndex & indexMask);
            if ((h >>> ProbeCountShift) < ++probes)
            {
                var tmp = h;
                h = (probes << ProbeCountShift) | (hRobinHooded & HashAndIndexMask);
                hRobinHooded = tmp;
                probes = hRobinHooded >>> ProbeCountShift;
            }
        }

        return ref map._entries.AddKeyAndGetValueRef(key, (map._count++) - StackEntriesCount);
    }

    ///<summary>Get the value ref by the entry index. Also the index corresponds to entry adding order.
    /// Important: it does not check the index bounds, so you need to check that the index is from 0 to map.Count-1</summary>
    [MethodImpl((MethodImplOptions)256)]
    public static ref Entry<K, V> GetSurePresentEntryRef<K, V, TEq, TEntries>(this ref SmallMap4<K, V, TEq, TEntries> map, int index)
        where TEq : struct, IEq<K>
        where TEntries : struct, IEntries<K, V, TEq>
    {
        Debug.Assert(index >= 0);
        Debug.Assert(index < map._count);
        if (index >= StackEntriesCount)
            return ref map._entries.GetSurePresentEntryRef(index - StackEntriesCount);
        switch (index)
        {
            case 0: return ref map._e0;
            case 1: return ref map._e1;
            case 2: return ref map._e2;
            case 3: return ref map._e3;
        }
        return ref RefTools<Entry<K, V>>.GetNullRef();
    }

    [MethodImpl((MethodImplOptions)256)]
    internal static ref V TryGetValueRefByHash<K, V, TEq, TEntries>(this ref SmallMap4<K, V, TEq, TEntries> map, K key, out bool found)
        where TEq : struct, IEq<K>
        where TEntries : struct, IEntries<K, V, TEq>
    {
        var hash = default(TEq).GetHashCode(key);

        var indexMask = (1 << map._capacityBitShift) - 1;
        var hashMiddleMask = HashAndIndexMask & ~indexMask;
        var hashMiddle = hash & hashMiddleMask;
        var hashIndex = hash & indexMask;

#if NET7_0_OR_GREATER
        ref var hashesAndIndexes = ref MemoryMarshal.GetArrayDataReference(map._packedHashesAndIndexes);
#else
        var hashesAndIndexes = map._packedHashesAndIndexes;
#endif

        var h = GetHash(ref hashesAndIndexes, hashIndex);

        // 1. Skip over hashes with the bigger and equal probes. The hashes with bigger probes overlapping from the earlier ideal positions
        var probes = 1;
        while ((h >>> ProbeCountShift) >= probes)
        {
            // 2. For the equal probes check for equality the hash middle part, and update the entry if the keys are equal too 
            if (((h >>> ProbeCountShift) == probes) & ((h & hashMiddleMask) == hashMiddle))
            {
                ref var e = ref map.GetSurePresentEntryRef(h & indexMask);
                if (default(TEq).Equals(e.Key, key))
                {
                    found = true;
                    return ref e.Value;
                }
            }

            h = GetHash(ref hashesAndIndexes, ++hashIndex & indexMask);
            ++probes;
        }

        found = false;
        return ref RefTools<V>.GetNullRef();
    }

    [MethodImpl((MethodImplOptions)256)]
    private static ref V AddOrGetValueRefByHash<K, V, TEq, TEntries>(this ref SmallMap4<K, V, TEq, TEntries> map, K key, out bool found)
        where TEq : struct, IEq<K>
        where TEntries : struct, IEntries<K, V, TEq>
    {
        // if the free space is less than 1/8 of capacity (12.5%) then Resize
        var indexMask = (1 << map._capacityBitShift) - 1;
        if (indexMask - map._count <= (indexMask >>> MinFreeCapacityShift))
            indexMask = map.ResizeHashes(indexMask);

        var hash = default(TEq).GetHashCode(key);
        var hashMiddleMask = HashAndIndexMask & ~indexMask;
        var hashMiddle = hash & hashMiddleMask;
        var hashIndex = hash & indexMask;

#if NET7_0_OR_GREATER
        ref var hashesAndIndexes = ref MemoryMarshal.GetArrayDataReference(map._packedHashesAndIndexes);
#else
        var hashesAndIndexes = map._packedHashesAndIndexes;
#endif
        ref var h = ref GetHashRef(ref hashesAndIndexes, hashIndex);

        // 1. Skip over hashes with the bigger and equal probes. The hashes with bigger probes overlapping from the earlier ideal positions
        var probes = 1;
        while ((h >>> ProbeCountShift) >= probes)
        {
            // 2. For the equal probes check for equality the hash middle part, and update the entry if the keys are equal too 
            if (((h >>> ProbeCountShift) == probes) & ((h & hashMiddleMask) == hashMiddle))
            {
                ref var e = ref map.GetSurePresentEntryRef(h & indexMask);
                if (default(TEq).Equals(e.Key, key))
                {
                    found = true;
                    return ref e.Value;
                }
            }
            h = ref GetHashRef(ref hashesAndIndexes, ++hashIndex & indexMask);
            ++probes;
        }

        // 3. We did not find the hash and therefore the key, so insert the new entry
        var hRobinHooded = h;
        h = (probes << ProbeCountShift) | hashMiddle | map._count;

        // 4. If the robin hooded hash is empty then we stop
        // 5. Otherwise we steal the slot with the smaller probes
        probes = hRobinHooded >>> ProbeCountShift;
        while (hRobinHooded != 0)
        {
            h = ref GetHashRef(ref hashesAndIndexes, ++hashIndex & indexMask);
            if ((h >>> ProbeCountShift) < ++probes)
            {
                var tmp = h;
                h = (probes << ProbeCountShift) | (hRobinHooded & HashAndIndexMask);
                hRobinHooded = tmp;
                probes = hRobinHooded >>> ProbeCountShift;
            }
        }
        found = false;
        return ref map._entries.AddKeyAndGetValueRef(key, (map._count++) - StackEntriesCount);
    }
}

// todo: @improve ? how/where to add SIMD to improve CPU utilization but not losing perf for smaller sizes
/// <summary>
/// Fast and less-allocating hash map without thread safety nets. Please measure it in your own use case before use.
/// It is configurable in regard of hash calculation/equality via `TEq` type parameter and 
/// in regard of key-value storage via `TEntries` type parameter.
/// 
/// Details:
/// - Implemented as a struct so that the empty/default map does not allocate on heap
/// - Hashes and key-values are the separate collections enabling better cash locality and faster performance (data-oriented design)
/// - No SIMD for now to avoid complexity and costs for the smaller maps, so the map is more fit for the smaller sizes.
/// - Provides the "stable" enumeration of the entries in the added order
/// - The TryRemove method removes the hash but replaces the key-value entry with the tombstone key and the default value.
/// For instance, for the `RefEq` the tombstone is <see langword="null"/>. You may redefine it in the `IEq{K}.GetTombstone()` implementation.
/// 
/// </summary>
[DebuggerDisplay("{Count} of {_e0}, {_e1}, {_e2}, {_e3}, ...")]
public struct SmallMap4<K, V, TEq, TEntries>
    where TEq : struct, IEq<K>
    where TEntries : struct, IEntries<K, V, TEq>
{
    internal byte _capacityBitShift;
    internal int _count;

    // The _packedHashesAndIndexes elements are of `Int32` with the bits split as following:
    // 00010|000...110|01101
    // |     |         |- The index into the _entries structure, 0-based. The index bit count (indexMask) is the hashes capacity - 1.
    // |     |         | This part of the erased hash is used to get the ideal index into the hashes array, so later this part of hash may be restored from the hash index and its probes.
    // |     |- The remaining middle bits of the original hash
    // |- 5 (MaxProbeBits) high bits of the Probe count, with the minimal value of b00001 indicating the non-empty slot.
    internal int[] _packedHashesAndIndexes;

#pragma warning disable IDE0044 // it tries to make entries readonly but they should stay modify-able to prevent its defensive struct copying  
    internal TEntries _entries;
#pragma warning restore IDE0044

    // todo: @improve how to configure how much we store on stack
    internal Entry<K, V> _e0, _e1, _e2, _e3;

    /// <summary>Capacity bits</summary>
    public int CapacityBitShift => _capacityBitShift;

    /// <summary>Access to the hashes and indexes</summary>
    public int[] PackedHashesAndIndexes => _packedHashesAndIndexes;

    /// <summary>Number of entries in the map</summary>
    public int Count => _count;

    /// <summary>Access to the key-value entries</summary>
    public TEntries Entries => _entries;

    /// <summary>Capacity calculates as `1 leftShift capacityBitShift`</summary>
    public SmallMap4(byte capacityBitShift)
    {
        _capacityBitShift = capacityBitShift;

        // the overflow tail to the hashes is the size of log2N where N==capacityBitShift, 
        // it is probably fine to have the check for the overflow of capacity because it will be mis-predicted only once at the end of loop (it even rarely for the lookup)
        _packedHashesAndIndexes = new int[1 << capacityBitShift];
        _entries = default;
        _entries.Init(capacityBitShift);
    }

    internal int ResizeHashes(int indexMask)
    {
        var oldCapacity = indexMask + 1;
        var newHashAndIndexMask = HashAndIndexMask & ~oldCapacity;
        var newIndexMask = (indexMask << 1) | 1;

        var newHashesAndIndexes = new int[oldCapacity << 1];

#if NET7_0_OR_GREATER
        ref var newHashes = ref MemoryMarshal.GetArrayDataReference(newHashesAndIndexes);
        ref var oldHashes = ref MemoryMarshal.GetArrayDataReference(_packedHashesAndIndexes);
        var oldHash = oldHashes;
#else
        var newHashes = newHashesAndIndexes;
        var oldHashes = _packedHashesAndIndexes;
        var oldHash = oldHashes[0];
#endif
        // Overflow segment is wrapped-around hashes and! the hashes at the beginning robin hooded by the wrapped-around hashes
        var i = 0;
        while ((oldHash >>> ProbeCountShift) > 1)
            oldHash = GetHash(ref oldHashes, ++i);

        var oldCapacityWithOverflowSegment = i + oldCapacity;
        while (true)
        {
            if (oldHash != 0)
            {
                // get the new hash index from the old one with the next bit equal to the `oldCapacity`
                var indexWithNextBit = (oldHash & oldCapacity) | (((i + 1) - (oldHash >>> ProbeCountShift)) & indexMask);

                // no need for robin-hooding because we already did it for the old hashes and now just filling the hashes into the new array which are already in order
                var probes = 1;
                ref var newHash = ref GetHashRef(ref newHashes, indexWithNextBit);
                while (newHash != 0)
                {
                    newHash = ref GetHashRef(ref newHashes, ++indexWithNextBit & newIndexMask);
                    ++probes;
                }
                newHash = (probes << ProbeCountShift) | (oldHash & newHashAndIndexMask);
            }
            if (++i >= oldCapacityWithOverflowSegment)
                break;

            oldHash = GetHash(ref oldHashes, i & indexMask);
        }
        ++_capacityBitShift;
        _packedHashesAndIndexes = newHashesAndIndexes;
        return newIndexMask;
    }
}
#nullable restore